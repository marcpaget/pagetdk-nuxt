import {
  useNodeRef
} from "./chunk-SZ2OXDKB.mjs";
import {
  parseCode,
  walkAst
} from "./chunk-VQNMI7UU.mjs";

// src/core/transform.ts
import MagicString from "magic-string";
import generate from "@babel/generator";
async function getTransformersByFile(transformer, id) {
  const transformers = (await Promise.all(
    transformer.map(async (t) => {
      if (t.transformInclude && !await t.transformInclude(id))
        return void 0;
      return {
        transformer: t,
        nodes: []
      };
    })
  )).filter((t) => !!t);
  return transformers;
}
var transform = async (code, id, options) => {
  const { getNodeRef } = useNodeRef();
  const transformers = await getTransformersByFile(options.transformer, id);
  if (transformers.length === 0)
    return;
  const program = parseCode(code, id, options.parserOptions);
  await walkAst(program, async (node, parent, index) => {
    var _a;
    for (const { transformer, nodes } of transformers) {
      if (transformer.onNode) {
        const bool = await ((_a = transformer.onNode) == null ? void 0 : _a.call(transformer, node, parent, index));
        if (!bool)
          continue;
      }
      nodes.push({
        node: getNodeRef(node)
      });
    }
  });
  const s = new MagicString(code);
  for (const { transformer, nodes } of transformers) {
    for (const { node } of nodes) {
      const value = node.value;
      if (!value)
        continue;
      const result = await transformer.transform(value, code, { id });
      if (result) {
        let newAST;
        if (typeof result === "string") {
          s.overwrite(value.start, value.end, result);
          newAST = parseCode(`{${result}}`, id, options.parserOptions).body[0].body[0];
          if (newAST.type === "ExpressionStatement") {
            newAST = newAST.expression;
          }
          newAST.start = value.start;
          newAST.end = value.end;
        } else {
          const generated = generate(result);
          let code2 = generated.code;
          if (result.type.endsWith("Expression"))
            code2 = `(${code2})`;
          s.overwrite(value.start, value.end, code2);
          newAST = result;
        }
        node.set(newAST);
      } else if (result === false) {
        node.set(void 0);
        s.remove(value.start, value.end);
      }
    }
  }
  if (!s.hasChanged())
    return void 0;
  return {
    code: s.toString(),
    get map() {
      return s.generateMap({
        source: id,
        includeContent: true
      });
    }
  };
};

export {
  transform
};
