"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _chunk7TD5SZB4js = require('./chunk-7TD5SZB4.js');



var _chunkPFSSVORSjs = require('./chunk-PFSSVORS.js');

// src/core/transform.ts
var _magicstring = require('magic-string'); var _magicstring2 = _interopRequireDefault(_magicstring);
var _generator = require('@babel/generator'); var _generator2 = _interopRequireDefault(_generator);
async function getTransformersByFile(transformer, id) {
  const transformers = (await Promise.all(
    transformer.map(async (t) => {
      if (t.transformInclude && !await t.transformInclude(id))
        return void 0;
      return {
        transformer: t,
        nodes: []
      };
    })
  )).filter((t) => !!t);
  return transformers;
}
var transform = async (code, id, options) => {
  const { getNodeRef } = _chunk7TD5SZB4js.useNodeRef.call(void 0, );
  const transformers = await getTransformersByFile(options.transformer, id);
  if (transformers.length === 0)
    return;
  const program = _chunkPFSSVORSjs.parseCode.call(void 0, code, id, options.parserOptions);
  await _chunkPFSSVORSjs.walkAst.call(void 0, program, async (node, parent, index) => {
    var _a;
    for (const { transformer, nodes } of transformers) {
      if (transformer.onNode) {
        const bool = await ((_a = transformer.onNode) == null ? void 0 : _a.call(transformer, node, parent, index));
        if (!bool)
          continue;
      }
      nodes.push({
        node: getNodeRef(node)
      });
    }
  });
  const s = new (0, _magicstring2.default)(code);
  for (const { transformer, nodes } of transformers) {
    for (const { node } of nodes) {
      const value = node.value;
      if (!value)
        continue;
      const result = await transformer.transform(value, code, { id });
      if (result) {
        let newAST;
        if (typeof result === "string") {
          s.overwrite(value.start, value.end, result);
          newAST = _chunkPFSSVORSjs.parseCode.call(void 0, `{${result}}`, id, options.parserOptions).body[0].body[0];
          if (newAST.type === "ExpressionStatement") {
            newAST = newAST.expression;
          }
          newAST.start = value.start;
          newAST.end = value.end;
        } else {
          const generated = _generator2.default.call(void 0, result);
          let code2 = generated.code;
          if (result.type.endsWith("Expression"))
            code2 = `(${code2})`;
          s.overwrite(value.start, value.end, code2);
          newAST = result;
        }
        node.set(newAST);
      } else if (result === false) {
        node.set(void 0);
        s.remove(value.start, value.end);
      }
    }
  }
  if (!s.hasChanged())
    return void 0;
  return {
    code: s.toString(),
    get map() {
      return s.generateMap({
        source: id,
        includeContent: true
      });
    }
  };
};



exports.transform = transform;
