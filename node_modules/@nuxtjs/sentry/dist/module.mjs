import { fileURLToPath } from 'url';
import { defu } from 'defu';
import { resolvePath } from 'mlly';
import * as Sentry from '@sentry/node';
import { autoDiscoverNodePerformanceMonitoringIntegrations, Integrations, withScope, captureException } from '@sentry/node';
import { existsSync } from 'node:fs';
import { consola } from 'consola';
import hash from 'hash-sum';
import { parse, basename, resolve, normalize, relative } from 'pathe';
import { resolveAlias as resolveAlias$1 } from 'pathe/utils';
import { getContext } from 'unctx';
import { resolve as resolve$1, posix } from 'path';
import * as PluggableIntegrations from '@sentry/integrations';

const nuxtCtx = getContext("nuxt");
function useNuxt() {
  const instance = nuxtCtx.tryUse();
  if (!instance) {
    throw new Error("Nuxt instance is unavailable!");
  }
  return instance;
}
function tryUseNuxt() {
  return nuxtCtx.tryUse();
}
const NUXT2_SHIMS_KEY = "__nuxt2_shims_key__";
function nuxt2Shims(nuxt) {
  if (nuxt[NUXT2_SHIMS_KEY]) {
    return;
  }
  nuxt[NUXT2_SHIMS_KEY] = true;
  nuxt.hooks = nuxt;
  if (!nuxtCtx.tryUse()) {
    nuxtCtx.set(nuxt);
    nuxt.hook("close", () => nuxtCtx.unset());
  }
}
function defineNuxtModule(definition) {
  if (!definition.meta) {
    definition.meta = {};
  }
  if (definition.meta.configKey === void 0) {
    definition.meta.configKey = definition.meta.name;
  }
  function getOptions(inlineOptions) {
    const nuxt = useNuxt();
    const configKey = definition.meta.configKey || definition.meta.name;
    const _defaults = definition.defaults instanceof Function ? definition.defaults(nuxt) : definition.defaults;
    const _options = defu(inlineOptions, nuxt.options[configKey], _defaults);
    return Promise.resolve(_options);
  }
  async function normalizedModule(inlineOptions) {
    const nuxt = this.nuxt;
    const uniqueKey = definition.meta.name || definition.meta.configKey;
    if (uniqueKey) {
      nuxt.options._requiredModules = nuxt.options._requiredModules || {};
      if (nuxt.options._requiredModules[uniqueKey]) {
        return false;
      }
      nuxt.options._requiredModules[uniqueKey] = true;
    }
    nuxt2Shims(nuxt);
    const _options = await getOptions(inlineOptions);
    const res = await definition.setup?.call(null, _options, nuxt) ?? {};
    return defu(res, {});
  }
  normalizedModule.getMeta = () => Promise.resolve(definition.meta);
  normalizedModule.getOptions = getOptions;
  return normalizedModule;
}
const logger$1 = consola;
function useLogger(tag) {
  return tag ? logger$1.withTag(tag) : logger$1;
}
function resolveAlias(path, alias) {
  if (!alias) {
    alias = tryUseNuxt()?.options.alias || {};
  }
  return resolveAlias$1(path, alias);
}
function normalizePlugin(plugin) {
  if (typeof plugin === "string") {
    plugin = { src: plugin };
  } else {
    plugin = { ...plugin };
  }
  if (!plugin.src) {
    throw new Error("Invalid plugin. src option is required: " + JSON.stringify(plugin));
  }
  const nonTopLevelPlugin = plugin.src.match(/\/plugins\/[^/]+\/index\.[^/]+$/i);
  if (nonTopLevelPlugin && nonTopLevelPlugin.length > 0 && !useNuxt().options.plugins.find((i) => (typeof i === "string" ? i : i.src).endsWith(nonTopLevelPlugin[0]))) {
    console.warn(`[warn] [nuxt] [deprecation] You are using a plugin that is within a subfolder of your plugins directory without adding it to your config explicitly. You can move it to the top-level plugins directory, or include the file '~${nonTopLevelPlugin[0]}' in your plugins config (https://nuxt.com/docs/api/configuration/nuxt-config#plugins-1) to remove this warning.`);
  }
  plugin.src = normalize(resolveAlias(plugin.src));
  if (plugin.ssr) {
    plugin.mode = "server";
  }
  if (!plugin.mode) {
    const [, mode = "all"] = plugin.src.match(/\.(server|client)(\.\w+)*$/) || [];
    plugin.mode = mode;
  }
  return plugin;
}
function addPlugin(_plugin, opts = {}) {
  const nuxt = useNuxt();
  const plugin = normalizePlugin(_plugin);
  nuxt.options.plugins = nuxt.options.plugins.filter((p) => normalizePlugin(p).src !== plugin.src);
  nuxt.options.plugins[opts.append ? "push" : "unshift"](plugin);
  return plugin;
}
function addPluginTemplate(plugin, opts = {}) {
  const normalizedPlugin = typeof plugin === "string" ? { src: plugin } : { ...plugin, src: addTemplate(plugin).dst };
  return addPlugin(normalizedPlugin, opts);
}
function addTemplate(_template) {
  const nuxt = useNuxt();
  const template = normalizeTemplate(_template);
  nuxt.options.build.templates = nuxt.options.build.templates.filter((p) => normalizeTemplate(p).filename !== template.filename);
  nuxt.options.build.templates.push(template);
  return template;
}
function normalizeTemplate(template) {
  if (!template) {
    throw new Error("Invalid template: " + JSON.stringify(template));
  }
  if (typeof template === "string") {
    template = { src: template };
  } else {
    template = { ...template };
  }
  if (template.src) {
    if (!existsSync(template.src)) {
      throw new Error("Template not found: " + template.src);
    }
    if (!template.filename) {
      const srcPath = parse(template.src);
      template.filename = template.fileName || `${basename(srcPath.dir)}.${srcPath.name}.${hash(template.src)}${srcPath.ext}`;
    }
  }
  if (!template.src && !template.getContents) {
    throw new Error("Invalid template. Either getContents or src options should be provided: " + JSON.stringify(template));
  }
  if (!template.filename) {
    throw new Error("Invalid template. Either filename should be provided: " + JSON.stringify(template));
  }
  if (template.filename.endsWith(".d.ts")) {
    template.write = true;
  }
  if (!template.dst) {
    const nuxt = useNuxt();
    template.dst = resolve(nuxt.options.buildDir, template.filename);
  }
  return template;
}
function addWebpackPlugin(plugin, options) {
  extendWebpackConfig((config) => {
    config.plugins = config.plugins || [];
    if (Array.isArray(plugin)) {
      config.plugins.push(...plugin);
    } else {
      config.plugins.push(plugin);
    }
  }, options);
}
function extendWebpackConfig(fn, options = {}) {
  const nuxt = useNuxt();
  if (options.dev === false && nuxt.options.dev) {
    return;
  }
  if (options.build === false && nuxt.options.build) {
    return;
  }
  nuxt.hook("webpack:config", (configs) => {
    if (options.server !== false) {
      const config = configs.find((i) => i.name === "server");
      if (config) {
        fn(config);
      }
    }
    if (options.client !== false) {
      const config = configs.find((i) => i.name === "client");
      if (config) {
        fn(config);
      }
    }
  });
}

const boolToText = (value) => value ? "enabled" : "disabled";
const envToBool = (env) => Boolean(env && env.toLowerCase() !== "false" && env !== "0");
const canInitialize = (options) => Boolean(options.initialize && options.dsn);
const clientSentryEnabled = (options) => !options.disabled && !options.disableClientSide;
const serverSentryEnabled = (options) => !options.disabled && !options.disableServerSide;
function callOnce(fn) {
  let called = false;
  return function callOnceWrapper(...subargs) {
    if (!called) {
      called = true;
      return fn(...subargs);
    }
  };
}

const BROWSER_INTEGRATIONS = ["Breadcrumbs", "Dedupe", "FunctionToString", "GlobalHandlers", "HttpContext", "InboundFilters", "LinkedErrors", "TryCatch"];
const BROWSER_PLUGGABLE_INTEGRATIONS = ["CaptureConsole", "Debug", "ExtraErrorData", "HttpClient", "ReportingObserver", "RewriteFrames"];
const BROWSER_VUE_INTEGRATIONS = ["Replay"];
const SERVER_INTEGRATIONS = ["Console", "ContextLines", "FunctionToString", "Http", "InboundFilters", "LinkedErrors", "LocalVariables", "Modules", "OnUncaughtException", "OnUnhandledRejection", "RequestData"];
const SERVER_PLUGGABLE_INTEGRATIONS = ["CaptureConsole", "Debug", "Dedupe", "ExtraErrorData", "RewriteFrames", "Transaction"];
function filterDisabledIntegrations(integrations) {
  return getIntegrationsKeys(integrations).filter((key) => integrations[key]);
}
function getIntegrationsKeys(integrations) {
  return Object.keys(integrations);
}
function isBrowserDefaultIntegration(name) {
  return BROWSER_INTEGRATIONS.includes(name);
}
function isBrowserPluggableIntegration(name) {
  return BROWSER_PLUGGABLE_INTEGRATIONS.includes(name);
}
function isBrowserVueIntegration(name) {
  return BROWSER_VUE_INTEGRATIONS.includes(name);
}
function isServerDefaultIntegration(name) {
  return SERVER_INTEGRATIONS.includes(name);
}
function isServerPlugabbleIntegration(name) {
  return SERVER_PLUGGABLE_INTEGRATIONS.includes(name);
}
async function getApiMethods(packageName) {
  const packageApi = await import(packageName);
  const apiMethods = [];
  for (const key in packageApi) {
    if (key === "default") {
      for (const subKey in packageApi[key]) {
        if (typeof packageApi[key][subKey] === "function") {
          apiMethods.push(subKey);
        }
      }
      continue;
    }
    if (typeof packageApi[key] === "function") {
      apiMethods.push(key);
    }
  }
  return apiMethods;
}
async function resolveRelease(moduleOptions) {
  if (!("release" in moduleOptions.config)) {
    try {
      const SentryCli = await import('@sentry/cli').then((m) => m.default || m);
      const cli = new SentryCli();
      return (await cli.releases.proposeVersion()).trim();
    } catch {
    }
  }
}
function resolveClientLazyOptions(options, apiMethods, logger) {
  if (options.lazy) {
    const defaultLazyOptions = {
      injectMock: true,
      injectLoadHook: false,
      mockApiMethods: true,
      chunkName: "sentry",
      webpackPrefetch: false,
      webpackPreload: false
    };
    options.lazy = defu(options.lazy, defaultLazyOptions);
    if (!options.lazy.injectMock) {
      options.lazy.mockApiMethods = [];
    } else if (options.lazy.mockApiMethods === true) {
      options.lazy.mockApiMethods = apiMethods;
    } else if (Array.isArray(options.lazy.mockApiMethods)) {
      const mockMethods = options.lazy.mockApiMethods;
      options.lazy.mockApiMethods = mockMethods.filter((method) => apiMethods.includes(method));
      const notfoundMethods = mockMethods.filter((method) => !apiMethods.includes(method));
      if (notfoundMethods.length) {
        logger.warn("Some specified methods to mock weren't found in @sentry/vue:", notfoundMethods);
      }
      if (!options.lazy.mockApiMethods.includes("captureException")) {
        options.lazy.mockApiMethods.push("captureException");
      }
    }
  }
}
function resolveTracingOptions(options, config) {
  if (!options.tracing) {
    return;
  }
  const defaultTracingOptions = {
    tracesSampleRate: 1,
    browserTracing: {},
    vueOptions: {
      trackComponents: true
    }
  };
  const userOptions = typeof options.tracing === "boolean" ? {} : options.tracing;
  const tracingOptions = defu(userOptions, defaultTracingOptions);
  if (config.tracesSampleRate === void 0) {
    config.tracesSampleRate = tracingOptions.tracesSampleRate;
  }
  options.tracing = tracingOptions;
  options.serverIntegrations = defu(options.serverIntegrations, { Http: { tracing: true } });
}
async function resolveClientOptions(nuxt, moduleOptions, logger) {
  const options = moduleOptions;
  let config = defu({}, options.config);
  let clientConfigPath;
  if (typeof options.clientConfig === "string") {
    clientConfigPath = resolveAlias(options.clientConfig);
    clientConfigPath = relative(nuxt.options.buildDir, clientConfigPath);
  } else {
    config = defu(options.clientConfig, options.config);
  }
  const apiMethods = await getApiMethods("@sentry/vue");
  resolveClientLazyOptions(options, apiMethods, logger);
  resolveTracingOptions(options, config);
  for (const name of getIntegrationsKeys(options.clientIntegrations)) {
    if (!isBrowserDefaultIntegration(name) && !isBrowserPluggableIntegration(name) && !isBrowserVueIntegration(name)) {
      logger.warn(`Sentry clientIntegration "${name}" is not recognized and will be ignored.`);
      delete options.clientIntegrations[name];
    }
  }
  let customClientIntegrations;
  if (options.customClientIntegrations) {
    if (typeof options.customClientIntegrations === "string") {
      customClientIntegrations = resolveAlias(options.customClientIntegrations);
      customClientIntegrations = relative(nuxt.options.buildDir, customClientIntegrations);
    } else {
      logger.warn(`Invalid customClientIntegrations option. Expected a file path, got "${typeof options.customClientIntegrations}".`);
    }
  }
  return {
    BROWSER_INTEGRATIONS,
    BROWSER_PLUGGABLE_INTEGRATIONS,
    BROWSER_VUE_INTEGRATIONS,
    dev: nuxt.options.dev,
    runtimeConfigKey: options.runtimeConfigKey,
    config: {
      dsn: options.dsn,
      ...config
    },
    clientConfigPath,
    lazy: options.lazy,
    apiMethods,
    customClientIntegrations,
    logMockCalls: options.logMockCalls,
    // for mocked only
    tracing: options.tracing,
    initialize: canInitialize(options),
    integrations: filterDisabledIntegrations(options.clientIntegrations).reduce((res, key) => {
      res[key] = options.clientIntegrations[key];
      return res;
    }, {})
  };
}
async function resolveServerOptions(nuxt, moduleOptions, logger) {
  const options = moduleOptions;
  for (const name of getIntegrationsKeys(options.serverIntegrations)) {
    if (!isServerDefaultIntegration(name) && !isServerPlugabbleIntegration(name)) {
      logger.warn(`Sentry serverIntegration "${name}" is not recognized and will be ignored.`);
      delete options.serverIntegrations[name];
    }
  }
  let customIntegrations = [];
  if (options.customServerIntegrations) {
    const resolvedPath = resolveAlias(options.customServerIntegrations);
    try {
      customIntegrations = (await import(resolvedPath).then((m) => m.default || m))();
      if (!Array.isArray(customIntegrations)) {
        logger.error(`Invalid value returned from customServerIntegrations plugin. Expected an array, got "${typeof customIntegrations}".`);
      }
    } catch (error) {
      logger.error(`Error handling the customServerIntegrations plugin:
${error}`);
    }
  }
  const defaultConfig = {
    dsn: options.dsn,
    integrations: [
      // Automatically instrument Node.js libraries and frameworks
      ...options.tracing ? autoDiscoverNodePerformanceMonitoringIntegrations() : [],
      ...filterDisabledIntegrations(options.serverIntegrations).map((name) => {
        const opt = options.serverIntegrations[name];
        try {
          if (isServerDefaultIntegration(name)) {
            return Object.keys(opt).length ? new Integrations[name](opt) : new Integrations[name]();
          } else if (isServerPlugabbleIntegration(name)) {
            return Object.keys(opt).length ? new PluggableIntegrations[name](opt) : new PluggableIntegrations[name]();
          } else {
            throw new Error(`Unsupported server integration "${name}"`);
          }
        } catch (error) {
          throw new Error(`Failed initializing server integration "${name}".
${error}`);
        }
      }),
      ...customIntegrations
    ]
  };
  let serverConfig = options.serverConfig;
  if (typeof serverConfig === "string") {
    const resolvedPath = resolveAlias(serverConfig);
    try {
      serverConfig = (await import(resolvedPath).then((m) => m.default || m))();
    } catch (error) {
      logger.error(`Error handling the serverConfig plugin:
${error}`);
    }
  }
  const config = defu(defaultConfig, options.config, options.serverConfig, getRuntimeConfig(nuxt, options));
  resolveTracingOptions(options, options.config);
  return {
    config,
    apiMethods: await getApiMethods("@sentry/node"),
    lazy: options.lazy,
    logMockCalls: options.logMockCalls,
    // for mocked only
    tracing: options.tracing
  };
}
function getRuntimeConfig(nuxt, options) {
  const { publicRuntimeConfig } = nuxt.options;
  const { runtimeConfigKey } = options;
  if (publicRuntimeConfig && typeof publicRuntimeConfig !== "function" && runtimeConfigKey in publicRuntimeConfig) {
    return defu(publicRuntimeConfig[runtimeConfigKey].config, publicRuntimeConfig[runtimeConfigKey].serverConfig);
  }
}

const RESOLVED_RELEASE_FILENAME = "sentry.release.config.mjs";
async function buildHook(nuxt, moduleOptions, logger) {
  const release = await resolveRelease(moduleOptions);
  const templateDir = fileURLToPath(new URL("./templates", import.meta.url));
  const pluginOptionClient = clientSentryEnabled(moduleOptions) && canInitialize(moduleOptions) ? moduleOptions.lazy ? "lazy" : "client" : "mocked";
  const clientOptions = defu({ config: { release } }, await resolveClientOptions(nuxt, moduleOptions, logger));
  addPluginTemplate({
    src: resolve$1(templateDir, `plugin.${pluginOptionClient}.js`),
    filename: "sentry.client.js",
    mode: "client",
    options: clientOptions
  });
  if (pluginOptionClient !== "mocked") {
    addTemplate({
      src: resolve$1(templateDir, "client.shared.js"),
      filename: "sentry.client.shared.js",
      options: clientOptions
    });
  }
  const pluginOptionServer = serverSentryEnabled(moduleOptions) ? "server" : "mocked";
  const serverOptions = defu({ config: { release } }, await resolveServerOptions(nuxt, moduleOptions, logger));
  addPluginTemplate({
    src: resolve$1(templateDir, `plugin.${pluginOptionServer}.js`),
    filename: "sentry.server.js",
    mode: "server",
    options: serverOptions
  });
  if (serverSentryEnabled(moduleOptions)) {
    addTemplate({
      src: resolve$1(templateDir, "options.ejs"),
      filename: RESOLVED_RELEASE_FILENAME,
      options: { release }
    });
  }
  if (!clientOptions.dev && !clientOptions.config.debug) {
    const webpack = await import('webpack').then((m) => m.default || m);
    addWebpackPlugin(new webpack.DefinePlugin({
      __SENTRY_DEBUG__: "false"
    }));
  }
}
async function webpackConfigHook(nuxt, webpackConfigs, options, logger) {
  let WebpackPlugin;
  try {
    WebpackPlugin = await import('@sentry/webpack-plugin').then((m) => m.default || m);
  } catch {
    throw new Error('The "@sentry/webpack-plugin" package must be installed as a dev dependency to use the "publishRelease" option.');
  }
  const publishRelease = defu({}, options.publishRelease);
  const nuxtOptions = nuxt.options;
  if (!publishRelease.urlPrefix) {
    if (typeof nuxtOptions.router.base === "string" && typeof nuxtOptions.build.publicPath === "string") {
      const publicPath = posix.join(nuxtOptions.router.base, nuxtOptions.build.publicPath);
      publishRelease.urlPrefix = publicPath.startsWith("/") ? `~${publicPath}` : publicPath;
    }
  }
  if (!Array.isArray(publishRelease.include)) {
    const { include } = publishRelease;
    publishRelease.include = [...include ? [include] : []];
  }
  const { buildDir } = nuxtOptions;
  if (!options.disableServerRelease) {
    publishRelease.include.push(`${buildDir}/dist/server`);
  }
  if (!options.disableClientRelease) {
    publishRelease.include.push(`${buildDir}/dist/client`);
  }
  publishRelease.release = options.config.release || publishRelease.release || await resolveRelease(options);
  if (!publishRelease.release) {
    logger.warn('Sentry release will not be published because "config.release" was not set nor it was possible to determine it automatically from the repository');
    return;
  }
  const attachCommits = envToBool(process.env.SENTRY_AUTO_ATTACH_COMMITS);
  if (attachCommits) {
    publishRelease.setCommits = publishRelease.setCommits || {};
    const { setCommits } = publishRelease;
    if (setCommits.auto === void 0) {
      setCommits.auto = true;
    }
    const repo = process.env.SENTRY_RELEASE_REPO || "";
    if (repo && setCommits.repo === void 0) {
      setCommits.repo = repo;
    }
  }
  for (const config2 of webpackConfigs) {
    config2.devtool = options.sourceMapStyle;
  }
  const config = webpackConfigs[webpackConfigs.length - 1];
  config.plugins = config.plugins || [];
  config.plugins.push(new WebpackPlugin(publishRelease));
}
async function initializeServerSentry(nuxt, moduleOptions, sentryHandlerProxy, logger) {
  if (process.sentry) {
    return;
  }
  let release;
  try {
    const path = resolve$1(nuxt.options.buildDir, RESOLVED_RELEASE_FILENAME);
    release = (await import(path)).release;
  } catch {
  }
  const serverOptions = await resolveServerOptions(nuxt, moduleOptions, logger);
  const config = defu({ release }, serverOptions.config);
  process.sentry = Sentry;
  if (canInitialize(moduleOptions)) {
    Sentry.init(config);
    sentryHandlerProxy.errorHandler = Sentry.Handlers.errorHandler();
    sentryHandlerProxy.requestHandler = Sentry.Handlers.requestHandler(moduleOptions.requestHandlerConfig);
    if (serverOptions.tracing) {
      sentryHandlerProxy.tracingHandler = Sentry.Handlers.tracingHandler();
    }
  }
}
async function shutdownServerSentry() {
  if (process.sentry) {
    await process.sentry.close();
    process.sentry = void 0;
  }
}

const logger = useLogger("nuxt:sentry");
const moduleDir = fileURLToPath(new URL("./", import.meta.url));
const module = defineNuxtModule({
  meta: {
    name: "@nuxtjs/sentry",
    configKey: "sentry"
  },
  defaults: (nuxt) => ({
    lazy: false,
    dsn: process.env.SENTRY_DSN || "",
    disabled: envToBool(process.env.SENTRY_DISABLED) || false,
    initialize: envToBool(process.env.SENTRY_INITIALIZE) || true,
    runtimeConfigKey: "sentry",
    disableClientSide: envToBool(process.env.SENTRY_DISABLE_CLIENT_SIDE) || false,
    disableServerSide: envToBool(process.env.SENTRY_DISABLE_SERVER_SIDE) || false,
    publishRelease: envToBool(process.env.SENTRY_PUBLISH_RELEASE) || false,
    disableServerRelease: envToBool(process.env.SENTRY_DISABLE_SERVER_RELEASE) || false,
    disableClientRelease: envToBool(process.env.SENTRY_DISABLE_CLIENT_RELEASE) || false,
    logMockCalls: true,
    sourceMapStyle: "source-map",
    tracing: false,
    clientIntegrations: {
      ExtraErrorData: {},
      ReportingObserver: { types: ["crash"] },
      RewriteFrames: {}
    },
    serverIntegrations: {
      Dedupe: {},
      ExtraErrorData: {},
      RewriteFrames: {},
      Transaction: {}
    },
    customClientIntegrations: "",
    customServerIntegrations: "",
    config: {
      environment: nuxt.options.dev ? "development" : "production"
    },
    serverConfig: {},
    clientConfig: {},
    requestHandlerConfig: {}
  }),
  async setup(options, nuxt) {
    const defaultsPublishRelease = {
      include: [],
      ignore: [
        "node_modules",
        ".nuxt/dist/client/img"
      ],
      configFile: ".sentryclirc"
    };
    if (options.publishRelease) {
      options.publishRelease = defu(options.publishRelease, defaultsPublishRelease);
    }
    if (canInitialize(options) && (clientSentryEnabled(options) || serverSentryEnabled(options))) {
      const status = `(client side: ${boolToText(clientSentryEnabled(options))}, server side: ${boolToText(serverSentryEnabled(options))})`;
      logger.success(`Sentry reporting is enabled ${status}`);
    } else {
      let why;
      if (options.disabled) {
        why = '"disabled" option has been set';
      } else if (!options.dsn) {
        why = "no DSN has been provided";
      } else if (!options.initialize) {
        why = '"initialize" option has been set to false';
      } else {
        why = "both client and server side clients are disabled";
      }
      logger.info(`Sentry reporting is disabled (${why})`);
    }
    const aliasedDependencies = [
      "lodash.mergewith",
      "@sentry/core",
      "@sentry/integrations",
      "@sentry/utils",
      "@sentry/vue"
    ];
    for (const dep of aliasedDependencies) {
      nuxt.options.alias[`~${dep}`] = (await resolvePath(dep, { url: moduleDir })).replace(/\/cjs\//, "/esm/");
    }
    nuxt.options.alias["~@sentry/browser-sdk"] = await resolvePath("@sentry/browser/esm/sdk", { url: moduleDir });
    if (serverSentryEnabled(options)) {
      const sentryHandlerProxy = {
        errorHandler: (error, _, __, next) => {
          next(error);
        },
        requestHandler: (_, __, next) => {
          next();
        },
        tracingHandler: (_, __, next) => {
          next();
        }
      };
      nuxt.hook("render:setupMiddleware", (app) => app.use((req, res, next) => {
        sentryHandlerProxy.requestHandler(req, res, next);
      }));
      if (options.tracing) {
        nuxt.hook("render:setupMiddleware", (app) => app.use((req, res, next) => {
          sentryHandlerProxy.tracingHandler(req, res, next);
        }));
      }
      nuxt.hook("render:errorMiddleware", (app) => app.use((error, req, res, next) => {
        sentryHandlerProxy.errorHandler(error, req, res, next);
      }));
      nuxt.hook("generate:routeFailed", ({ route, errors }) => {
        errors.forEach(({ error }) => withScope((scope) => {
          scope.setExtra("route", route);
          captureException(error);
        }));
      });
      {
        const isBuilding = nuxt.options._build && !nuxt.options.dev;
        const initHook = isBuilding ? "build:compile" : "ready";
        nuxt.hook(initHook, () => initializeServerSentry(nuxt, options, sentryHandlerProxy, logger));
        const shutdownHook = isBuilding ? "build:done" : "close";
        const shutdownServerSentryOnce = callOnce(() => shutdownServerSentry());
        nuxt.hook(shutdownHook, shutdownServerSentryOnce);
      }
    }
    nuxt.hook("build:before", () => buildHook(nuxt, options, logger));
    if (options.publishRelease && !options.disabled && !nuxt.options.dev) {
      {
        nuxt.hook("webpack:config", (webpackConfigs) => webpackConfigHook(nuxt, webpackConfigs, options, logger));
      }
    }
  }
});

export { module as default };
