import { defineNuxtModule } from '@nuxt/kit';
import chalk from 'chalk';
import { parseURL, hasProtocol } from 'ufo';
import { load } from 'cheerio';
import { toRouteMatcher, createRouter } from 'radix3';

const linkMap = {};
const EXT_REGEX = /\.[\da-z]+$/;
const allowedExtensions = /* @__PURE__ */ new Set(["", ".json"]);
function getExtension(path) {
  return (path.match(EXT_REGEX) || [])[0] || "";
}
function extractLinks(html, from, { host, trailingSlash }) {
  const links = [];
  const hostname = parseURL(host).host;
  const $ = load(html);
  $("body [href]").each((i, el) => {
    const href = $(el).attr("href");
    if (!href)
      return;
    const url = parseURL(href);
    if (hasProtocol(href) && !href.startsWith("/") && url.host !== hostname)
      return;
    if (href.startsWith("#"))
      return;
    if (el.tagName === "link" && el.attribs.rel === "canonical")
      return;
    if (!allowedExtensions.has(getExtension(href)))
      return;
    links.push({
      pathname: url.pathname || "/",
      url,
      badAbsolute: Boolean(hostname) && hostname === url.host,
      badTrailingSlash: url.pathname !== "/" && !url.pathname.split("/").at(-1).includes(".") && (trailingSlash && !url.pathname.endsWith("/") || !trailingSlash && url.pathname.endsWith("/")),
      element: $.html(el) || ""
    });
  });
  return links;
}

function createFilter(options = {}) {
  const include = options.include || [];
  const exclude = options.exclude || [];
  if (include.length === 0 && exclude.length === 0)
    return () => true;
  return function(path) {
    for (const v of [{ rules: exclude, result: false }, { rules: include, result: true }]) {
      const regexRules = v.rules.filter((r) => r instanceof RegExp);
      if (regexRules.some((r) => r.test(path)))
        return v.result;
      const stringRules = v.rules.filter((r) => typeof r === "string");
      if (stringRules.length > 0) {
        const routes = {};
        for (const r of stringRules) {
          if (r === path)
            return v.result;
          routes[r] = true;
        }
        const routeRulesMatcher = toRouteMatcher(createRouter({ routes, ...options }));
        if (routeRulesMatcher.matchAll(path).length > 0)
          return Boolean(v.result);
      }
    }
    return include.length === 0;
  };
}

const invalidStatusCodes = [404, 302, 301, 307, 303];
const module = defineNuxtModule({
  meta: {
    name: "nuxt-link-checker",
    compatibility: {
      nuxt: "^3.0.0",
      bridge: false
    },
    configKey: "linkChecker"
  },
  defaults(nuxt) {
    return {
      host: process.env.NUXT_PUBLIC_SITE_URL || nuxt.options.runtimeConfig.public?.siteUrl || "localhost",
      trailingSlash: process.env.NUXT_PUBLIC_TRAILING_SLASH || nuxt.options.runtimeConfig.public?.trailingSlash || false,
      failOn404: true,
      exclude: []
    };
  },
  setup(config, nuxt) {
    if (nuxt.options.dev)
      return;
    const urlFilter = createFilter({
      exclude: config.exclude
    });
    nuxt.hooks.hook("nitro:init", async (nitro) => {
      const invalidRoutes = {};
      nitro.hooks.hook("prerender:generate", async (ctx) => {
        if (ctx.contents && ctx.fileName?.endsWith(".html"))
          linkMap[ctx.route] = extractLinks(ctx.contents, ctx.route, config);
        if (ctx.error?.statusCode && invalidStatusCodes.includes(Number(ctx.error?.statusCode)))
          invalidRoutes[ctx.route] = ctx.error.statusCode;
      });
      nitro.hooks.hook("close", async () => {
        const links = Object.entries(linkMap);
        if (!links.length)
          return;
        nitro.logger.info(`Scanning routes for broken links... ${chalk.gray(`trailingSlashes: ${config.trailingSlash ? "`true`" : "`false`"}`)}`);
        let routeCount = 0;
        let badLinkCount = 0;
        links.forEach(([route, routes]) => {
          const brokenLinks = routes.map((r) => {
            return {
              ...r,
              statusCode: invalidRoutes[r.pathname] || 200
            };
          }).filter((r) => r.statusCode !== 200 || r.badTrailingSlash || r.badAbsolute).filter((r) => urlFilter(r.pathname));
          if (brokenLinks.length) {
            nitro.logger.log(chalk.gray(
              `  ${Number(++routeCount) === links.length - 1 ? "\u2514\u2500" : "\u251C\u2500"} ${chalk.white(route)}`
            ));
            brokenLinks.forEach((link) => {
              badLinkCount++;
              nitro.logger.log("");
              if (link.statusCode !== 200) {
                nitro.logger.log(chalk.red(
                  `   ${link.statusCode} ${link.statusCode === 404 ? "Not Found" : "Redirect"}`
                ));
              } else if (link.badAbsolute) {
                nitro.logger.log(chalk.yellow(
                  "   Absolute link, should be relative"
                ));
              } else if (link.badTrailingSlash) {
                nitro.logger.log(chalk.yellow(
                  "   Incorrect trailing slash"
                ));
              }
              nitro.logger.log(`   ${chalk.gray(link.element)}`);
            });
          }
        });
        if (badLinkCount > 0) {
          nitro.logger[config.failOn404 ? "error" : "warn"](`Found ${badLinkCount} broken links.`);
          if (config.failOn404) {
            nitro.logger.log(chalk.gray('You can disable this by setting "linkChecker: { failOn404: false }" in your nuxt.config.ts.'));
            process.exit(1);
          }
        } else {
          nitro.logger.success("Looks good! No broken links found.");
        }
      });
    });
  }
});

export { module as default };
