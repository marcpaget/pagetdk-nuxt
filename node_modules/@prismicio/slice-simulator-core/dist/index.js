import { SimulatorAPI, ClientRequestType, ResponseError } from '@prismicio/slice-simulator-com';
import * as t from 'io-ts';

const LibrariesStateLike = t.record(
  t.string,
  t.intersection([
    t.partial({
      name: t.string
    }),
    t.type({
      components: t.record(
        t.string,
        t.intersection([
          t.type({
            id: t.string,
            model: t.intersection([
              t.type({
                id: t.string,
                variations: t.array(
                  t.intersection([
                    t.type({ id: t.string }),
                    t.partial({ name: t.string })
                  ])
                )
              }),
              t.partial({ name: t.string })
            ]),
            mocks: t.record(t.string, t.type({ variation: t.string }))
          }),
          t.partial({
            name: t.string
          })
        ])
      )
    })
  ])
);
var StateManagerEventType = /* @__PURE__ */ ((StateManagerEventType2) => {
  StateManagerEventType2["ManagedState"] = "managedState";
  StateManagerEventType2["Slices"] = "slices";
  StateManagerEventType2["ActiveSlice"] = "activeSlice";
  StateManagerEventType2["Message"] = "message";
  return StateManagerEventType2;
})(StateManagerEventType || {});
var StateManagerStatus = /* @__PURE__ */ ((StateManagerStatus2) => {
  StateManagerStatus2["Pending"] = "pending";
  StateManagerStatus2["Loaded"] = "loaded";
  StateManagerStatus2["Error"] = "error";
  return StateManagerStatus2;
})(StateManagerStatus || {});

const getDefaultProps = () => ({
  state: {},
  zIndex: 100,
  background: "#ffffff"
});
const getDefaultManagedState = () => ({
  data: null,
  status: StateManagerStatus.Pending,
  error: null
});
const getDefaultSlices = () => {
  return [];
};
const getDefaultMessage = () => {
  return "";
};

const simulatorClass = "slice-simulator";
const simulatorRootClass = "slice-simulator--root";
const getSliceZoneDOM = (expectedNumberOfChildren) => {
  let node = document.querySelector(`.${simulatorClass} [data-slice-zone]`);
  if (node) {
    if (node.children.length !== expectedNumberOfChildren) {
      console.warn(
        `Flagged SliceZone has an unexpected number of children, found ${node.children.length} but expected ${expectedNumberOfChildren}. This might lead to unexpected behaviors. Are you sure you tagged the right element?`
      );
    }
    return node;
  }
  node = document.querySelector(`.${simulatorClass} .${simulatorRootClass}`);
  if (!node) {
    return null;
  }
  const searchDepth = 5;
  for (let i = 0; i < searchDepth; i++) {
    if (node.children.length === expectedNumberOfChildren) {
      return node;
    } else if (node.children.length) {
      node = node.children[0];
    } else {
      break;
    }
  }
  return null;
};
const getActiveSliceDOM = ($sliceZone, mouse) => {
  const raycast = document.elementsFromPoint(mouse.x, mouse.y).reverse();
  const sliceZoneIndex = raycast.indexOf($sliceZone);
  if (sliceZoneIndex === -1) {
    return null;
  }
  const $slice = raycast[sliceZoneIndex + 1];
  if (!$slice) {
    return null;
  }
  return $slice;
};

const div = (content) => `<div style="word-spacing: initial; white-space: pre; line-height: initial; font-family: monospace; color: #ffffff; mix-blend-mode: difference; padding: 1rem; font-size: 1rem;">${content}</div>`;
const a = (href, label) => `<a href="${href}" style="text-decoration: underline;">${label || href}<a>`;
const header = "   _____ ___          _____ _                 __      __            \n  / ___// (_)_______ / ___/(_)___ ___  __  __/ /___ _/ /_____  _____\n  \\__ \\/ / / ___/ _ \\\\__ \\/ / __ `__ \\/ / / / / __ `/ __/ __ \\/ ___/\n ___/ / / / /__/  __/__/ / / / / / / / /_/ / / /_/ / /_/ /_/ / /    \n/____/_/_/\\___/\\___/____/_/_/ /_/ /_/\\__,_/_/\\__,_/\\__/\\____/_/     \n                  / /_  __  __   / __ \\_____(_)________ ___  (_)____\n                 / __ \\/ / / /  / /_/ / ___/ / ___/ __ `__ \\/ / ___/\n                / /_/ / /_/ /  / ____/ /  / (__  ) / / / / / / /__  \n               /_.___/\\__, /  /_/   /_/  /_/____/_/ /_/ /_/_/\\___/  \n                     /____/\n\n";
const footer = "\n\n\n\n\n\n                                                - The Prismic team";
const sliceSimulatorAccessedDirectly = div(
  [
    header,
    `You're seeing this page because you're accessing Slice Simulator
directly, e.g:

  - ${a(
      "http://localhost:3000/slice-simulator"
    )}



Slice Simulator is not meant to be accessed this way, to preview your
slices, head over to Slice Machine UI:

  - ${a(
      "http://localhost:9999"
    )}



If you believe this is an error, please reach out to us:

  - ${a(
      "https://github.com/prismicio/slice-machine/issues/new/choose"
    )}`,
    footer
  ].join("")
);

class EventEmitter {
  constructor() {
    this._listeners = {};
  }
  on(event, listener, key = null) {
    var _a;
    this._listeners[event] = [
      ...(_a = this._listeners[event]) != null ? _a : [],
      [listener, key]
    ];
  }
  off(event, listenerOrKey) {
    var _a;
    this._listeners[event] = ((_a = this._listeners[event]) != null ? _a : []).filter(
      ([listener, key]) => typeof listenerOrKey === "function" ? listener !== listenerOrKey : key !== listenerOrKey
    );
  }
  emit(event, payload) {
    var _a;
    ((_a = this._listeners[event]) != null ? _a : []).forEach((listener) => listener[0](payload));
  }
}

const throttle = (fn, delay = 16) => {
  let lastExec = 0;
  let timer = null;
  return function(...args) {
    const now = Date.now();
    const delta = now - lastExec;
    if (delta >= delay) {
      fn.apply(this, args);
      lastExec = now;
    } else {
      if (timer) {
        clearTimeout(timer);
      }
      timer = setTimeout(() => {
        fn.apply(this, args);
        lastExec = Date.now();
      }, delay - delta);
    }
  };
};

if (typeof process === "undefined") {
  globalThis.process = { env: {} };
}
const __PRODUCTION__ = process.env.NODE_ENV === "production";

class StateManager extends EventEmitter {
  constructor(managedState = getDefaultManagedState(), slices = getDefaultSlices()) {
    super();
    this._setActiveSlice = () => {
      if (this.slices.length === 0) {
        this.activeSlice = null;
        return;
      }
      const $sliceZone = getSliceZoneDOM(this.slices.length);
      if (!$sliceZone) {
        this.activeSlice = null;
        return;
      }
      const $activeSlice = getActiveSliceDOM($sliceZone, this._mouse);
      if (!$activeSlice) {
        this.activeSlice = null;
        return;
      }
      const activeSliceIndex = Array.prototype.indexOf.call(
        $sliceZone.children,
        $activeSlice
      );
      this.activeSlice = {
        rect: $activeSlice.getBoundingClientRect(),
        sliceID: this.slices[activeSliceIndex].slice_type,
        variationID: this.slices[activeSliceIndex].variation,
        index: activeSliceIndex
      };
    };
    this.setActiveSlice = throttle(this._setActiveSlice, 16);
    this._setSliceZoneFromSliceIDsLastCall = null;
    this._managedState = managedState;
    this._slices = slices;
    this._activeSlice = null;
    this._message = "";
    this._mouse = { x: 0, y: 0 };
  }
  set managedState(managedState) {
    this._managedState = managedState;
    this.emit(StateManagerEventType.ManagedState, managedState);
  }
  get managedState() {
    return this._managedState;
  }
  set slices(slices) {
    this._slices = slices;
    this.message = "";
    this.emit(StateManagerEventType.Slices, slices);
  }
  get slices() {
    return this._slices;
  }
  set activeSlice(activeSlice) {
    this._activeSlice = activeSlice;
    this.emit(StateManagerEventType.ActiveSlice, activeSlice);
  }
  get activeSlice() {
    return this._activeSlice;
  }
  set message(message) {
    this._message = message;
    this.emit(StateManagerEventType.Message, message);
  }
  get message() {
    return this._message;
  }
  async init(state) {
    this._managedState = await this.load(state);
    if (__PRODUCTION__) {
      await this.forceSliceChunksDownload();
    }
    this.setDefaultSliceZone();
    this.emit(StateManagerEventType.ManagedState, this._managedState);
    window.addEventListener("mousemove", (event) => {
      this._mouse = { x: event.clientX, y: event.clientY };
    });
  }
  async load(state) {
    try {
      const raw = await (typeof state === "function" ? state() : state);
      const res = LibrariesStateLike.decode(raw);
      if (res._tag === "Left") {
        console.error(res.left);
        throw new Error(
          "State does not validate expected format, see console logs for detailed report"
        );
      }
      return {
        data: res.right,
        status: StateManagerStatus.Loaded,
        error: null
      };
    } catch (error) {
      console.error(error);
      return {
        data: null,
        status: StateManagerStatus.Error,
        error
      };
    }
  }
  async reload(state) {
    this.managedState = await this.load(state);
    this.recoverSliceZone();
  }
  _throwIfNotLoaded(methodName) {
    var _a;
    if (this.managedState.status === StateManagerStatus.Error) {
      throw (_a = this.managedState.error) != null ? _a : new Error("Unknown state error, see console logs for detailed report");
    } else if (this.managedState.status === StateManagerStatus.Pending || !this.managedState.data) {
      throw new Error(
        `\`StateManager.${methodName}()\` can only be called when the state is loaded, use \`StateManager.load()\` first`
      );
    }
  }
  getLibraries() {
    this._throwIfNotLoaded("getLibraries");
    return Object.entries(this.managedState.data).map(
      ([libraryPath, library]) => {
        const sliceMap = library.components;
        return {
          path: libraryPath,
          slices: Object.values(sliceMap).map((slice) => {
            return {
              id: slice.id,
              name: slice.name || slice.id,
              variations: slice.model.variations.map((variation) => {
                return {
                  id: variation.id,
                  name: variation.name || variation.id
                };
              })
            };
          })
        };
      }
    );
  }
  getMocks() {
    this._throwIfNotLoaded("getMocks");
    return Object.values(this.managedState.data).reduce((acc, library) => {
      const sliceMap = library.components;
      Object.values(sliceMap).forEach((slice) => {
        acc[slice.id] = Object.values(slice.mocks).reduce((acc2, mock) => {
          acc2[mock.variation] = mock;
          return acc2;
        }, {});
      });
      return acc;
    }, {});
  }
  async forceSliceChunksDownload() {
    this.setSliceZoneFromSliceIDs(
      this.getLibraries().map((library) => {
        return library.slices.map((slice) => {
          return {
            sliceID: slice.id,
            variationID: slice.variations[0].id
          };
        });
      }).flat()
    );
    await new Promise((resolve) => setTimeout(resolve, 0));
    this.slices = [];
  }
  setDefaultSliceZone() {
    this._throwIfNotLoaded("setDefaultSliceZone");
    if (typeof window !== "undefined") {
      const url = new URL(window.location.href);
      if (url.searchParams.has("sid") && url.searchParams.has("vid")) {
        this.setSliceZoneFromSliceIDs([
          {
            sliceID: url.searchParams.get("sid"),
            variationID: url.searchParams.get("vid")
          }
        ]);
      }
    }
  }
  recoverSliceZone() {
    if (this._setSliceZoneFromSliceIDsLastCall) {
      this.setSliceZoneFromSliceIDs(this._setSliceZoneFromSliceIDsLastCall);
    }
  }
  setSliceZone(slices) {
    this._setSliceZoneFromSliceIDsLastCall = null;
    this.slices = slices;
  }
  setSliceZoneFromSliceIDs(slices) {
    this._setSliceZoneFromSliceIDsLastCall = slices;
    const mocks = this.getMocks();
    this.slices = slices.map((slice) => {
      const sliceID = slice.sliceID;
      const variationID = slice.variationID;
      if (sliceID in mocks && variationID in mocks[sliceID]) {
        return mocks[sliceID][variationID];
      }
    }).filter(Boolean);
  }
}

class CoreManager {
  constructor(managedState = getDefaultManagedState(), slices = getDefaultSlices()) {
    this.stateManager = new StateManager(managedState, slices);
    this._api = null;
    this._initialized = false;
  }
  async init(state) {
    if (this._initialized) {
      await this.stateManager.reload(state);
      return;
    } else {
      this._initialized = true;
    }
    await this.stateManager.init(state);
    try {
      await this._initAPI();
    } catch (error) {
      if (error instanceof Error && error.message === "Receiver is currently not embedded as an iframe" && !this.stateManager.slices.length) {
        this.stateManager.message = sliceSimulatorAccessedDirectly;
      }
      console.error(error);
      return;
    }
    this._initListeners();
  }
  async _initAPI() {
    this._api = new SimulatorAPI({
      [ClientRequestType.GetLibraries]: (_req, res) => {
        return res.success(this.stateManager.getLibraries());
      },
      [ClientRequestType.SetSliceZone]: (req, res) => {
        this.stateManager.setSliceZone(req.data);
        return res.success();
      },
      [ClientRequestType.SetSliceZoneFromSliceIDs]: (req, res) => {
        this.stateManager.setSliceZoneFromSliceIDs(req.data);
        return res.success();
      },
      [ClientRequestType.ScrollToSlice]: (req, res) => {
        var _a;
        if (req.data.sliceIndex < 0) {
          return res.error("`sliceIndex` must be > 0", 400);
        } else if (req.data.sliceIndex >= this.stateManager.slices.length) {
          return res.error(
            `\`sliceIndex\` must be < ${this.stateManager.slices.length} (\`<SliceZone />\` current length)`,
            400
          );
        }
        const $sliceZone = getSliceZoneDOM(this.stateManager.slices.length);
        if (!$sliceZone) {
          return res.error("Failed to find `<SliceZone />`", 500);
        }
        this.stateManager.activeSlice = null;
        const $slice = $sliceZone.children[req.data.sliceIndex];
        if (!$slice) {
          return res.error(
            `Failed fo find slice at index $\`{req.data.sliceIndex}\` in \`<SliceZone />\``,
            500
          );
        }
        $slice.scrollIntoView({
          behavior: req.data.behavior,
          block: req.data.block,
          inline: req.data.inline
        });
        ((_a = this._api) == null ? void 0 : _a.options.activeSliceAPI) && setTimeout(this.stateManager.setActiveSlice, 750);
        return res.success();
      }
    });
    await this._api.ready();
  }
  _initListeners() {
    window.addEventListener("mousemove", () => {
      var _a;
      ((_a = this._api) == null ? void 0 : _a.options.activeSliceAPI) && this.stateManager.setActiveSlice();
    });
    window.addEventListener("resize", () => {
      var _a;
      ((_a = this._api) == null ? void 0 : _a.options.activeSliceAPI) && this.stateManager.setActiveSlice();
    });
    window.addEventListener("mousewheel", () => {
      var _a;
      ((_a = this._api) == null ? void 0 : _a.options.activeSliceAPI) && setTimeout(this.stateManager.setActiveSlice, 200);
    });
    this.stateManager.on(StateManagerEventType.Slices, () => {
      var _a;
      ((_a = this._api) == null ? void 0 : _a.options.activeSliceAPI) && this.stateManager.setActiveSlice();
    });
    this.stateManager.on(
      StateManagerEventType.ActiveSlice,
      async (activeSlice) => {
        if (this._api) {
          try {
            await this._api.setActiveSlice(activeSlice);
          } catch (error) {
            if (error instanceof ResponseError && error.response.status === 400) {
              console.error(error.response);
            } else {
              throw error;
            }
          }
        }
      }
    );
  }
}

const disableEventHandler = (event) => {
  event.preventDefault();
  event.stopPropagation();
};
const onClickHandler = (event) => {
  if (event.path && event.path.slice(0, 5).some((el) => el instanceof HTMLAnchorElement)) {
    event.preventDefault();
    event.stopPropagation();
  }
};

export { CoreManager, StateManager, StateManagerEventType, StateManagerStatus, disableEventHandler, getActiveSliceDOM, getDefaultManagedState, getDefaultMessage, getDefaultProps, getDefaultSlices, getSliceZoneDOM, onClickHandler, simulatorClass, simulatorRootClass, sliceSimulatorAccessedDirectly };
//# sourceMappingURL=index.js.map
