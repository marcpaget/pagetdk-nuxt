import statuses from 'statuses';

let requestID = 0;
const createRequestMessage = (type, data, prefix = "") => {
  return {
    requestID: `${prefix}${requestID++}`,
    type,
    data
  };
};
const createSuccessResponseMessage = (requestID2, data, status = 200) => {
  var _a, _b;
  if (status >= 400) {
    throw new TypeError(
      `Invalid success status code, expected status to be within \`[100;400[\`, got \`${status}\``
    );
  }
  return {
    requestID: requestID2,
    status,
    msg: (_b = (_a = statuses.message[status]) == null ? void 0 : _a.replace(/\.$/, "").toLowerCase()) != null ? _b : "",
    data
  };
};
const createErrorResponseMessage = (requestID2, error, status = 400) => {
  var _a, _b;
  if (status < 400) {
    throw new TypeError(
      `Invalid error status code, expected status to be within \`[500;600[\`, got \`${status}\``
    );
  }
  return {
    requestID: requestID2,
    status,
    msg: (_b = (_a = statuses.message[status]) == null ? void 0 : _a.replace(/\.$/, "").toLowerCase()) != null ? _b : "",
    error
  };
};
const validateMessage = (message) => {
  if (typeof message !== "object" || message === null) {
    throw new TypeError(
      `Invalid message received, expected message to be of type \`object\`, got \`${typeof message}\``
    );
  } else if (!Object.keys(message).every(
    (key) => ["requestID", "type", "data", "status", "msg", "error"].includes(key)
  )) {
    throw new TypeError(`Invalid message received: ${JSON.stringify(message)}`);
  } else if (typeof message.requestID !== "string") {
    throw new TypeError(
      `Invalid message received, expected \`message.requestID\` to be of type \`string\`, got \`${typeof message.id}\``
    );
  }
  return message;
};
const isRequestMessage = (message) => {
  return "type" in message;
};
const isResponseMessage = (message) => {
  return !("type" in message);
};
const isSuccessResponseMessage = (message) => {
  return isResponseMessage(message) && !("error" in message);
};
const isErrorResponseMessage = (message) => {
  return isResponseMessage(message) && !("data" in message);
};

class ResponseError extends Error {
  constructor(errorResponse) {
    super(errorResponse.msg);
    this.response = errorResponse;
  }
}
class ConnectionTimeoutError extends Error {
  constructor() {
    super("Connection timed out");
  }
}
class TooManyConcurrentRequestsError extends Error {
  constructor(request) {
    super(`Too many concurrent requests`);
    this.request = request;
  }
}
class RequestTimeoutError extends Error {
  constructor(request) {
    super(`Request \`${request.requestID}\` timed out`);
    this.request = request;
  }
}
class NotReadyError extends Error {
}
class PortNotSetError extends Error {
  constructor() {
    super("Port is not set");
  }
}
class ChannelNotSetError extends Error {
  constructor() {
    super("Channel is not set");
  }
}

const channelNetworkDefaultOptions = {
  debug: false,
  maximumRequestConcurrency: 20,
  defaultTimeout: 5e3,
  requestIDPrefix: "channel-"
};
class ChannelNetwork {
  constructor(requestHandlers, options) {
    this._port = null;
    this._pendingRequests = /* @__PURE__ */ new Map();
    this.requestHandlers = requestHandlers;
    this.options = { ...channelNetworkDefaultOptions, ...options };
  }
  get port() {
    if (!this._port) {
      throw new PortNotSetError();
    }
    return this._port;
  }
  set port(port) {
    if (this._port) {
      this._port.onmessage = null;
    }
    this._port = port;
    if (this._port) {
      this._port.onmessage = this.onMessage.bind(this);
    }
  }
  createRequestMessage(type, data) {
    return createRequestMessage(type, data, this.options.requestIDPrefix);
  }
  async onMessage(event) {
    if (this.options.debug) {
      console.debug(event.data);
    }
    try {
      const message = validateMessage(event.data);
      if (isRequestMessage(message)) {
        if (!this.requestHandlers[message.type]) {
          this.postResponse(
            createErrorResponseMessage(message.requestID, void 0, 501)
          );
        } else {
          try {
            const response = await this.requestHandlers[message.type](message, {
              success: createSuccessResponseMessage.bind(
                this,
                message.requestID
              ),
              error: createErrorResponseMessage.bind(
                this,
                message.requestID
              )
            });
            this.postResponse(response);
          } catch (error) {
            this.postResponse(
              createErrorResponseMessage(message.requestID, error, 500)
            );
          }
        }
      } else {
        if (!this._pendingRequests.has(message.requestID)) {
          console.error(
            `Unknown request ID received in response: ${JSON.stringify(
              message
            )}`
          );
        } else {
          this._pendingRequests.get(message.requestID)(message);
          this._pendingRequests.delete(message.requestID);
        }
      }
    } catch (error) {
      if (error instanceof TypeError) {
        console.warn(error.message);
      } else {
        throw error;
      }
    }
  }
  postRequest(request, postMessage = (request2) => this.port.postMessage(request2), options = {}) {
    if (this.options.debug) {
      console.debug(request);
    }
    if (this._pendingRequests.size >= this.options.maximumRequestConcurrency) {
      throw new TooManyConcurrentRequestsError(request);
    }
    return new Promise(
      (resolve, reject) => {
        const requestTimeout = setTimeout(() => {
          if (this._pendingRequests.has(request.requestID)) {
            this._pendingRequests.delete(request.requestID);
          }
          reject(new RequestTimeoutError(request));
        }, options.timeout || this.options.defaultTimeout);
        this._pendingRequests.set(
          request.requestID,
          (response) => {
            clearTimeout(requestTimeout);
            isSuccessResponseMessage(response) ? resolve(response) : reject(
              new ResponseError(
                response
              )
            );
          }
        );
        postMessage(request);
      }
    );
  }
  postResponse(response, postMessage = (response2) => this.port.postMessage(response2)) {
    if (this.options.debug) {
      console.debug(response);
    }
    postMessage(response);
    return response;
  }
}

var InternalEmitterRequestType = /* @__PURE__ */ ((InternalEmitterRequestType2) => {
  InternalEmitterRequestType2["Connect"] = "connect";
  return InternalEmitterRequestType2;
})(InternalEmitterRequestType || {});
var InternalReceiverRequestType = /* @__PURE__ */ ((InternalReceiverRequestType2) => {
  InternalReceiverRequestType2["Ready"] = "ready";
  return InternalReceiverRequestType2;
})(InternalReceiverRequestType || {});

const channelEmitterDefaultOptions = {
  connectTimeout: 2e4,
  requestIDPrefix: "emitter-"
};
class ChannelEmitter extends ChannelNetwork {
  constructor(target, requestHandlers, options) {
    super(requestHandlers, { ...channelEmitterDefaultOptions, ...options });
    this._channel = null;
    this._receiverReady = "";
    this._receiverReadyCallback = null;
    this._connected = false;
    this._target = target;
    window.addEventListener("message", (event) => {
      this._onPublicMessage(event);
    });
  }
  get channel() {
    if (!this._channel) {
      throw new ChannelNotSetError();
    }
    return this._channel;
  }
  set channel(channel) {
    this._channel = channel;
    if (this._channel) {
      this.port = this._channel.port1;
    } else {
      this.port = null;
    }
  }
  get connected() {
    return this._connected;
  }
  connect(receiverOptions = {}, newOrigin = false) {
    this.disconnect();
    if (newOrigin) {
      this._receiverReady = "";
    }
    return new Promise((resolve, reject) => {
      this._target.addEventListener(
        "load",
        () => {
          if (!this._target.contentWindow) {
            return reject(new Error("Target window is not available"));
          }
          const receiverReadyTimeout = setTimeout(() => {
            reject(new ConnectionTimeoutError());
          }, this.options.connectTimeout);
          const receiverReadyCallback = async () => {
            clearTimeout(receiverReadyTimeout);
            this.channel = new MessageChannel();
            const request = this.createRequestMessage(
              InternalEmitterRequestType.Connect,
              receiverOptions
            );
            const response = await this.postRequest(request, (request2) => {
              this._target.contentWindow.postMessage(request2, "*", [
                this.channel.port2
              ]);
            });
            this.postResponse(
              createSuccessResponseMessage(this._receiverReady, void 0),
              (response2) => {
                this._target.contentWindow.postMessage(response2, "*");
              }
            );
            this._connected = true;
            resolve(response);
          };
          if (this._receiverReady) {
            receiverReadyCallback();
          } else {
            this._receiverReadyCallback = receiverReadyCallback;
          }
        },
        { once: true }
      );
    });
  }
  disconnect() {
    this._connected = false;
    this.channel = null;
  }
  async _onPublicMessage(event) {
    if (event.source !== this._target.contentWindow) {
      return;
    }
    try {
      const message = validateMessage(event.data);
      if (isRequestMessage(message)) {
        if (this.options.debug) {
          console.debug(event.data);
        }
        switch (message.type) {
          case InternalReceiverRequestType.Ready:
            this._receiverReady = message.requestID;
            if (this._receiverReadyCallback) {
              const receiverReadyCallbackPromise = this._receiverReadyCallback();
              this._receiverReadyCallback = null;
              await receiverReadyCallbackPromise;
            }
            break;
          default:
            this.postResponse(
              createErrorResponseMessage(message.requestID, void 0),
              (response) => {
                event.source.postMessage(
                  response,
                  event.origin
                );
              }
            );
            break;
        }
      } else {
      }
    } catch (error) {
      if (error instanceof TypeError) ; else {
        throw error;
      }
    }
  }
  postFormattedRequest(type, data, options = {}) {
    if (!this._connected) {
      throw new NotReadyError(
        "Emitter is not connected, use `ChannelEmitter.connect()` first"
      );
    }
    return this.postRequest(
      this.createRequestMessage(type, data),
      void 0,
      options
    );
  }
}

const channelReceiverDefaultOptions = {
  readyTimeout: 2e4,
  requestIDPrefix: "receiver-"
};
class ChannelReceiver extends ChannelNetwork {
  constructor(requestHandlers, options) {
    super(requestHandlers, { ...channelReceiverDefaultOptions, ...options });
    this._ready = false;
    window.addEventListener("message", (event) => {
      this._onPublicMessage(event);
    });
  }
  async ready() {
    if (window.parent === window) {
      throw new Error("Receiver is currently not embedded as an iframe");
    }
    this._ready = false;
    const request = this.createRequestMessage(
      InternalReceiverRequestType.Ready,
      void 0
    );
    const response = await this.postRequest(
      request,
      (request2) => {
        window.parent.postMessage(request2, "*");
      },
      {
        timeout: this.options.readyTimeout
      }
    );
    this._ready = true;
    return response;
  }
  _onPublicMessage(event) {
    try {
      const message = validateMessage(event.data);
      if (isRequestMessage(message)) {
        if (this.options.debug) {
          console.debug(event.data);
        }
        switch (message.type) {
          case InternalEmitterRequestType.Connect:
            this.port = event.ports[0];
            const { data } = message;
            this.options = {
              ...this.options,
              ...data,
              debug: this.options.debug,
              requestIDPrefix: this.options.requestIDPrefix,
              readyTimeout: this.options.readyTimeout
            };
            const response = createSuccessResponseMessage(
              message.requestID,
              void 0
            );
            this.postResponse(response);
            break;
          default:
            this.postResponse(
              createErrorResponseMessage(message.requestID, void 0),
              (response2) => {
                event.source.postMessage(
                  response2,
                  event.origin
                );
              }
            );
            break;
        }
      } else {
        if (!this._ready) {
          this.onMessage(event);
        }
      }
    } catch (error) {
      if (error instanceof TypeError) ; else {
        throw error;
      }
    }
  }
  postFormattedRequest(type, data, options = {}) {
    if (!this._ready) {
      throw new NotReadyError(
        "Receiver is not ready, use `ChannelReceiver.ready()` first"
      );
    }
    return this.postRequest(
      this.createRequestMessage(type, data),
      void 0,
      options
    );
  }
}

var APIRequestType = /* @__PURE__ */ ((APIRequestType2) => {
  APIRequestType2["SetActiveSlice"] = "setActiveSlice";
  return APIRequestType2;
})(APIRequestType || {});
var ClientRequestType = /* @__PURE__ */ ((ClientRequestType2) => {
  ClientRequestType2["Ping"] = "ping";
  ClientRequestType2["GetLibraries"] = "getLibraries";
  ClientRequestType2["SetSliceZone"] = "setSliceZone";
  ClientRequestType2["SetSliceZoneFromSliceIDs"] = "setSliceZoneFromSliceIDs";
  ClientRequestType2["ScrollToSlice"] = "scrollToSlice";
  return ClientRequestType2;
})(ClientRequestType || {});

var _a$1, _b, _c, _d, _e;
const simulatorClientDefaultOptions = {
  requestIDPrefix: "client-"
};
class SimulatorClient extends ChannelEmitter {
  constructor(target, requestHandlers, options) {
    var _a2, _b2;
    const debug = (options == null ? void 0 : options.debug) || /[\?&]debug=true/i.test(decodeURIComponent(window.location.search));
    super(
      target,
      {
        [APIRequestType.SetActiveSlice]: (_req, res) => {
          return res.success();
        },
        ...requestHandlers
      },
      {
        ...simulatorClientDefaultOptions,
        ...options,
        debug
      }
    );
    this[_a$1] = async () => {
      return await this.postFormattedRequest(ClientRequestType.Ping);
    };
    this[_b] = async () => {
      return await this.postFormattedRequest(ClientRequestType.GetLibraries);
    };
    this[_c] = async (data) => {
      return await this.postFormattedRequest(
        ClientRequestType.SetSliceZone,
        data
      );
    };
    this[_d] = async (data) => {
      return await this.postFormattedRequest(
        ClientRequestType.SetSliceZoneFromSliceIDs,
        data
      );
    };
    this[_e] = async (data) => {
      return await this.postFormattedRequest(
        ClientRequestType.ScrollToSlice,
        data
      );
    };
    if (debug) {
      window.prismic || (window.prismic = {});
      (_a2 = window.prismic).sliceSimulator || (_a2.sliceSimulator = {});
      (_b2 = window.prismic.sliceSimulator).client || (_b2.client = []);
      window.prismic.sliceSimulator.client.push(this);
    }
  }
}
_a$1 = ClientRequestType.Ping, _b = ClientRequestType.GetLibraries, _c = ClientRequestType.SetSliceZone, _d = ClientRequestType.SetSliceZoneFromSliceIDs, _e = ClientRequestType.ScrollToSlice;

var _a;
const simulatorAPIDefaultOptions = {
  requestIDPrefix: "api-",
  activeSliceAPI: false
};
class SimulatorAPI extends ChannelReceiver {
  constructor(requestHandlers, options) {
    var _a2, _b;
    const debug = (options == null ? void 0 : options.debug) || /[\?&]debug=true/i.test(decodeURIComponent(window.location.search));
    super(
      {
        [ClientRequestType.Ping]: (_req, res) => {
          return res.success("pong");
        },
        ...requestHandlers
      },
      {
        ...simulatorAPIDefaultOptions,
        ...options,
        debug
      }
    );
    this[_a] = async (data) => {
      return await this.postFormattedRequest(APIRequestType.SetActiveSlice, data);
    };
    if (debug) {
      window.prismic || (window.prismic = {});
      (_a2 = window.prismic).sliceSimulator || (_a2.sliceSimulator = {});
      (_b = window.prismic.sliceSimulator).api || (_b.api = []);
      window.prismic.sliceSimulator.api.push(this);
    }
  }
}
_a = APIRequestType.SetActiveSlice;

export { APIRequestType, ChannelNotSetError, ClientRequestType, ConnectionTimeoutError, NotReadyError, PortNotSetError, RequestTimeoutError, ResponseError, SimulatorAPI, SimulatorClient, TooManyConcurrentRequestsError, isErrorResponseMessage, isRequestMessage, isResponseMessage, isSuccessResponseMessage, simulatorAPIDefaultOptions, simulatorClientDefaultOptions, validateMessage };
//# sourceMappingURL=index.js.map
