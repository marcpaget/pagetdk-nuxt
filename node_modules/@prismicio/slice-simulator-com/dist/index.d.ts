import { SliceZone } from '@prismicio/types';

type MessageBase = {
    requestID: string;
};
type RequestMessage<TType extends string = string, TData = void> = {
    type: TType;
    data: TData;
} & MessageBase;
type ResponseMessageBase = {
    status: number;
    msg: string;
} & MessageBase;
type SuccessResponseMessage<TData = void> = {
    data: TData;
    error?: never;
} & ResponseMessageBase;
type ErrorResponseMessage<TError = unknown> = {
    data?: never;
    error: unknown | TError;
} & ResponseMessageBase;
type ResponseMessage<TData = void, TError = unknown> = SuccessResponseMessage<TData> | ErrorResponseMessage<TError>;
type ExtractSuccessResponseMessage<TResponse extends UnknownResponseMessage> = Extract<TResponse, {
    error?: never;
}>;
type ExtractErrorResponseMessage<TResponse extends UnknownResponseMessage> = Extract<TResponse, {
    data?: never;
}>;
type UnknownRequestMessage = RequestMessage<string, unknown>;
type UnknownSuccessResponseMessage = SuccessResponseMessage<unknown>;
type UnknownErrorResponseMessage = ErrorResponseMessage<unknown>;
type UnknownResponseMessage = UnknownSuccessResponseMessage | UnknownErrorResponseMessage;
type UnknownMessage = UnknownRequestMessage | UnknownResponseMessage;
type Transaction<TRequest extends UnknownRequestMessage, TResponse extends UnknownResponseMessage = ResponseMessage<void>> = {
    request: TRequest;
    response: TResponse;
};
type TransactionMethod<TTransaction extends Transaction<UnknownRequestMessage, UnknownResponseMessage>> = (data: TTransaction["request"]["data"]) => Promise<ExtractSuccessResponseMessage<TTransaction["response"]>>;
type TransactionHandler<TTransaction extends Transaction<UnknownRequestMessage, UnknownResponseMessage>> = (request: TTransaction["request"], response: {
    success: (data: ExtractSuccessResponseMessage<TTransaction["response"]>["data"], status?: number) => ExtractSuccessResponseMessage<TTransaction["response"]>;
    error: (error: ExtractErrorResponseMessage<TTransaction["response"]>["error"], status?: number) => ExtractErrorResponseMessage<TTransaction["response"]>;
}) => Promise<TTransaction["response"]> | TTransaction["response"];
type TransactionsMethods<TTransactions extends Record<string, UnknownTransaction>> = {
    [Key in keyof TTransactions]: TransactionMethod<TTransactions[Key]>;
};
type TransactionsHandlers<TTransactions extends Record<string, UnknownTransaction>> = {
    [Key in keyof TTransactions]: TransactionHandler<TTransactions[Key]>;
};
type UnknownTransaction = Transaction<UnknownRequestMessage, UnknownResponseMessage>;
declare enum InternalEmitterRequestType {
    Connect = "connect"
}
type InternalEmitterTransactions<TReceiverOptions extends Record<string, unknown> = Record<string, unknown>> = {
    [InternalEmitterRequestType.Connect]: Transaction<RequestMessage<InternalEmitterRequestType.Connect, Partial<Omit<TReceiverOptions, "debug" | "requestIDPrefix" | "readyTimeout">> | undefined>>;
};

type PostRequestOptions = {
    timeout?: number;
};
type ChannelNetworkOptions = {
    debug: boolean;
    maximumRequestConcurrency: number;
    defaultTimeout: number;
    requestIDPrefix: string;
};
declare abstract class ChannelNetwork<TPartnerTransactions extends Record<string, UnknownTransaction> = Record<string, never>, TOptions extends Record<string, unknown> = Record<string, unknown>> {
    requestHandlers: TransactionsHandlers<TPartnerTransactions>;
    options: ChannelNetworkOptions & TOptions;
    private _port;
    protected get port(): MessagePort;
    protected set port(port: MessagePort | null);
    private _pendingRequests;
    constructor(requestHandlers: TransactionsHandlers<TPartnerTransactions>, options: Partial<ChannelNetworkOptions> & TOptions);
    createRequestMessage<TType extends string = string, TData = undefined>(type: TType, data: TData): RequestMessage<TType, TData>;
    protected onMessage(event: MessageEvent<unknown>): Promise<void>;
    protected postRequest<TRequest extends UnknownRequestMessage, TResponse extends UnknownResponseMessage>(request: TRequest, postMessage?: (request: TRequest) => void, options?: PostRequestOptions): Promise<ExtractSuccessResponseMessage<TResponse>>;
    protected postResponse<TResponse extends UnknownResponseMessage>(response: TResponse, postMessage?: (response: TResponse) => void): TResponse;
}

type ChannelReceiverOptions = {
    readyTimeout: number;
};
type AllChannelReceiverOptions = ChannelReceiverOptions & ChannelNetworkOptions;
declare abstract class ChannelReceiver<TEmitterTransactions extends Record<string, UnknownTransaction> = Record<string, never>, TOptions extends Record<string, unknown> = Record<string, unknown>> extends ChannelNetwork<TEmitterTransactions, ChannelReceiverOptions & TOptions> {
    private _ready;
    constructor(requestHandlers: TransactionsHandlers<TEmitterTransactions>, options: Partial<AllChannelReceiverOptions> & TOptions);
    /**
     * Tells the emitter that receiver is ready
     */
    ready(): Promise<SuccessResponseMessage>;
    /**
     * Handles public messages
     */
    private _onPublicMessage;
    protected postFormattedRequest<TRequest extends UnknownRequestMessage, TResponse extends UnknownResponseMessage>(type: TRequest["type"], data?: TRequest["data"], options?: PostRequestOptions): Promise<ExtractSuccessResponseMessage<TResponse>>;
}

type ChannelEmitterOptions = {
    connectTimeout: number;
};
type AllChannelEmitterOptions = ChannelEmitterOptions & ChannelNetworkOptions;
declare abstract class ChannelEmitter<TReceiverTransactions extends Record<string, UnknownTransaction> = Record<string, never>, TOptions extends Record<string, unknown> = Record<string, unknown>, TReceiverOptions extends Record<string, unknown> = Record<string, unknown>> extends ChannelNetwork<TReceiverTransactions, ChannelEmitterOptions & TOptions> {
    private _target;
    private _channel;
    protected get channel(): MessageChannel;
    protected set channel(channel: MessageChannel | null);
    private _receiverReady;
    private _receiverReadyCallback;
    private _connected;
    get connected(): boolean;
    constructor(target: HTMLIFrameElement, requestHandlers: TransactionsHandlers<TReceiverTransactions>, options: Partial<AllChannelEmitterOptions> & TOptions);
    /**
     * Initiates connection to receiver
     *
     * @param receiverOptions - Options to configure the receiver with
     * @param newOrigin - Indicates to the emitter that we're connecting to a new
     *   origin
     *
     * @returns Success connect message
     */
    connect(receiverOptions?: InternalEmitterTransactions<AllChannelReceiverOptions & TReceiverOptions>["connect"]["request"]["data"], newOrigin?: boolean): Promise<SuccessResponseMessage>;
    /**
     * Destroys current connection to receiver if any
     */
    disconnect(): void;
    /**
     * Handles public messages
     */
    private _onPublicMessage;
    protected postFormattedRequest<TRequest extends UnknownRequestMessage, TResponse extends UnknownResponseMessage>(type: TRequest["type"], data?: TRequest["data"], options?: PostRequestOptions): Promise<ExtractSuccessResponseMessage<TResponse>>;
}

declare const validateMessage: (message: unknown) => UnknownMessage;
declare const isRequestMessage: (message: UnknownMessage) => message is UnknownRequestMessage;
declare const isResponseMessage: (message: UnknownMessage) => message is UnknownResponseMessage;
declare const isSuccessResponseMessage: (message: UnknownMessage) => message is UnknownSuccessResponseMessage;
declare const isErrorResponseMessage: (message: UnknownMessage) => message is UnknownErrorResponseMessage;

declare class ResponseError<TErrorResponse extends UnknownErrorResponseMessage> extends Error {
    response: TErrorResponse;
    constructor(errorResponse: TErrorResponse);
}
declare class ConnectionTimeoutError extends Error {
    constructor();
}
declare class TooManyConcurrentRequestsError extends Error {
    request: UnknownRequestMessage;
    constructor(request: UnknownRequestMessage);
}
declare class RequestTimeoutError<TRequest extends UnknownRequestMessage> extends Error {
    request: UnknownRequestMessage;
    constructor(request: TRequest);
}
declare class NotReadyError extends Error {
}
declare class PortNotSetError extends Error {
    constructor();
}
declare class ChannelNotSetError extends Error {
    constructor();
}

type ActiveSlice = {
    rect: DOMRect;
    sliceID: string;
    variationID: string;
    index: number;
};
type VariationSummary = {
    name: string;
    id: string;
};
type SliceSummary = {
    name: string;
    id: string;
    variations: VariationSummary[];
};
type LibrarySummary = {
    path: string;
    slices: SliceSummary[];
};
declare enum APIRequestType {
    SetActiveSlice = "setActiveSlice"
}
type APITransactions = {
    [APIRequestType.SetActiveSlice]: Transaction<RequestMessage<APIRequestType.SetActiveSlice, ActiveSlice | null>>;
};
declare enum ClientRequestType {
    Ping = "ping",
    GetLibraries = "getLibraries",
    SetSliceZone = "setSliceZone",
    SetSliceZoneFromSliceIDs = "setSliceZoneFromSliceIDs",
    ScrollToSlice = "scrollToSlice"
}
type ClientTransactions = {
    [ClientRequestType.Ping]: Transaction<RequestMessage<ClientRequestType.Ping>, ResponseMessage<"pong">>;
    [ClientRequestType.GetLibraries]: Transaction<RequestMessage<ClientRequestType.GetLibraries>, ResponseMessage<LibrarySummary[]>>;
    [ClientRequestType.SetSliceZone]: Transaction<RequestMessage<ClientRequestType.SetSliceZone, SliceZone>>;
    [ClientRequestType.SetSliceZoneFromSliceIDs]: Transaction<RequestMessage<ClientRequestType.SetSliceZoneFromSliceIDs, {
        sliceID: string;
        variationID: string;
    }[]>>;
    [ClientRequestType.ScrollToSlice]: Transaction<RequestMessage<ClientRequestType.ScrollToSlice, {
        sliceIndex: number;
        behavior?: "auto" | "smooth";
        block?: "start" | "center" | "end" | "nearest";
        inline?: "start" | "center" | "end" | "nearest";
    }>>;
};

type SimulatorAPIOptions = {
    activeSliceAPI: boolean;
};
declare const simulatorAPIDefaultOptions: Partial<AllChannelReceiverOptions> & SimulatorAPIOptions;
declare class SimulatorAPI extends ChannelReceiver<ClientTransactions, SimulatorAPIOptions> implements TransactionsMethods<APITransactions> {
    constructor(requestHandlers: Omit<TransactionsHandlers<ClientTransactions>, ClientRequestType.Ping> & Partial<Pick<TransactionsHandlers<ClientTransactions>, ClientRequestType.Ping>>, options?: Partial<AllChannelReceiverOptions & SimulatorAPIOptions>);
    [APIRequestType.SetActiveSlice]: TransactionMethod<APITransactions[APIRequestType.SetActiveSlice]>;
}

declare const simulatorClientDefaultOptions: Partial<AllChannelEmitterOptions>;
declare class SimulatorClient extends ChannelEmitter<APITransactions, Partial<AllChannelEmitterOptions>, SimulatorAPIOptions> implements TransactionsMethods<ClientTransactions> {
    constructor(target: HTMLIFrameElement, requestHandlers?: Partial<TransactionsHandlers<APITransactions>>, options?: Partial<AllChannelEmitterOptions>);
    [ClientRequestType.Ping]: TransactionMethod<ClientTransactions[ClientRequestType.Ping]>;
    [ClientRequestType.GetLibraries]: TransactionMethod<ClientTransactions[ClientRequestType.GetLibraries]>;
    [ClientRequestType.SetSliceZone]: TransactionMethod<ClientTransactions[ClientRequestType.SetSliceZone]>;
    [ClientRequestType.SetSliceZoneFromSliceIDs]: TransactionMethod<ClientTransactions[ClientRequestType.SetSliceZoneFromSliceIDs]>;
    [ClientRequestType.ScrollToSlice]: TransactionMethod<ClientTransactions[ClientRequestType.ScrollToSlice]>;
}

export { APIRequestType, APITransactions, ActiveSlice, AllChannelEmitterOptions, AllChannelReceiverOptions, ChannelNotSetError, ClientRequestType, ClientTransactions, ConnectionTimeoutError, ErrorResponseMessage, LibrarySummary, NotReadyError, PortNotSetError, RequestMessage, RequestTimeoutError, ResponseError, ResponseMessage, SimulatorAPI, SimulatorAPIOptions, SimulatorClient, SliceSummary, SuccessResponseMessage, TooManyConcurrentRequestsError, VariationSummary, isErrorResponseMessage, isRequestMessage, isResponseMessage, isSuccessResponseMessage, simulatorAPIDefaultOptions, simulatorClientDefaultOptions, validateMessage };
