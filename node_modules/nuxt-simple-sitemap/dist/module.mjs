import { writeFile } from 'node:fs/promises';
import { Readable } from 'node:stream';
import { useNuxt, addTemplate, resolveFiles, defineNuxtModule, createResolver, addServerHandler, useLogger } from '@nuxt/kit';
import { defu } from 'defu';
import { SitemapStream, streamToPromise } from 'sitemap';
import { toRouteMatcher, createRouter } from 'radix3';
import chalk from 'chalk';
import { encodePath, withoutBase, withoutTrailingSlash, withBase, withTrailingSlash } from 'ufo';
import { resolve, relative, extname } from 'pathe';
import 'knitwork';
import escapeRE from 'escape-string-regexp';

function createFilter(options = {}) {
  const include = options.include || [];
  const exclude = options.exclude || [];
  if (include.length === 0 && exclude.length === 0)
    return () => true;
  return function(path) {
    for (const v of [{ rules: exclude, result: false }, { rules: include, result: true }]) {
      const regexRules = v.rules.filter((r) => r instanceof RegExp);
      if (regexRules.some((r) => r.test(path)))
        return v.result;
      const stringRules = v.rules.filter((r) => typeof r === "string");
      if (stringRules.length > 0) {
        const routes = {};
        for (const r of stringRules) {
          if (r === path)
            return v.result;
          routes[r] = true;
        }
        const routeRulesMatcher = toRouteMatcher(createRouter({ routes, ...options }));
        if (routeRulesMatcher.matchAll(path).length > 0)
          return Boolean(v.result);
      }
    }
    return include.length === 0;
  };
}

function exposeModuleConfig(moduleName, config) {
  const nuxt = useNuxt();
  const jsExports = Object.entries(config).map(([k, v]) => `export const ${k} = ${JSON.stringify(v)}`).join("\n");
  const alias = `#${moduleName}/config`;
  nuxt.options.alias[alias] = addTemplate({
    filename: `modules/config/${moduleName}.mjs`,
    getContents: () => jsExports
  }).dst;
  nuxt.hooks.hook("nitro:config", (nitroConfig) => {
    nitroConfig.virtual[alias] = jsExports;
  });
  const typeDefName = `modules/config/${moduleName}.d.ts`;
  const tsExports = Object.keys(config).map((k) => {
    if (nuxt.options.dev)
      return `  export const ${k}: ${JSON.stringify(config[k])} | ModuleOptions['${k}']`;
    return `  export const ${k}: ModuleOptions['${k}']`;
  }).join("\n");
  addTemplate({
    filename: typeDefName,
    getContents: () => {
      return `// generated by ${moduleName}
import type { ModuleOptions } from '${moduleName}'
declare module '${alias}' {
${tsExports}
}
`;
    }
  });
  nuxt.hooks.hook("prepare:types", ({ references }) => {
    references.push({ path: resolve(nuxt.options.buildDir, typeDefName) });
  });
  return alias;
}

function uniqueBy(arr, key) {
  const res = [];
  const seen = /* @__PURE__ */ new Set();
  for (const item of arr) {
    if (seen.has(item[key]))
      continue;
    seen.add(item[key]);
    res.push(item);
  }
  return res;
}
async function resolvePagesRoutes() {
  const nuxt = useNuxt();
  const pagesDirs = nuxt.options._layers.map(
    (layer) => resolve(layer.config.srcDir, layer.config.dir?.pages || "pages")
  );
  const allRoutes = (await Promise.all(
    pagesDirs.map(async (dir) => {
      const files = await resolveFiles(dir, `**/*{${nuxt.options.extensions.join(",")}}`);
      files.sort();
      return generateRoutesFromFiles(files, dir);
    })
  )).flat();
  return uniqueBy(allRoutes, "path");
}
function generateRoutesFromFiles(files, pagesDir) {
  const routes = [];
  for (const file of files) {
    const segments = relative(pagesDir, file).replace(new RegExp(`${escapeRE(extname(file))}$`), "").split("/");
    const route = {
      name: "",
      path: "",
      file,
      children: []
    };
    let parent = routes;
    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i];
      const tokens = parseSegment(segment);
      const segmentName = tokens.map(({ value }) => value).join("");
      route.name += (route.name && "-") + segmentName;
      const child = parent.find((parentRoute) => parentRoute.name === route.name && !parentRoute.path.endsWith("(.*)*"));
      if (child && child.children) {
        parent = child.children;
        route.path = "";
      } else if (segmentName === "index" && !route.path) {
        route.path += "/";
      } else if (segmentName !== "index") {
        route.path += getRoutePath(tokens);
      }
    }
    parent.push(route);
  }
  return prepareRoutes(routes);
}
function getRoutePath(tokens) {
  return tokens.reduce((path, token) => {
    return path + (token.type === 2 /* optional */ ? `:${token.value}?` : token.type === 1 /* dynamic */ ? `:${token.value}` : token.type === 3 /* catchall */ ? `:${token.value}(.*)*` : encodePath(token.value));
  }, "/");
}
const PARAM_CHAR_RE = /[\w\d_.]/;
function parseSegment(segment) {
  let state = 0 /* initial */;
  let i = 0;
  let buffer = "";
  const tokens = [];
  function consumeBuffer() {
    if (!buffer)
      return;
    if (state === 0 /* initial */)
      throw new Error("wrong state");
    tokens.push({
      type: state === 1 /* static */ ? 0 /* static */ : state === 2 /* dynamic */ ? 1 /* dynamic */ : state === 3 /* optional */ ? 2 /* optional */ : 3 /* catchall */,
      value: buffer
    });
    buffer = "";
  }
  while (i < segment.length) {
    const c = segment[i];
    switch (state) {
      case 0 /* initial */:
        buffer = "";
        if (c === "[") {
          state = 2 /* dynamic */;
        } else {
          i--;
          state = 1 /* static */;
        }
        break;
      case 1 /* static */:
        if (c === "[") {
          consumeBuffer();
          state = 2 /* dynamic */;
        } else {
          buffer += c;
        }
        break;
      case 4 /* catchall */:
      case 2 /* dynamic */:
      case 3 /* optional */:
        if (buffer === "...") {
          buffer = "";
          state = 4 /* catchall */;
        }
        if (c === "[" && state === 2 /* dynamic */)
          state = 3 /* optional */;
        if (c === "]" && (state !== 3 /* optional */ || buffer[buffer.length - 1] === "]")) {
          if (!buffer)
            throw new Error("Empty param");
          else
            consumeBuffer();
          state = 0 /* initial */;
        } else if (PARAM_CHAR_RE.test(c)) {
          buffer += c;
        } else ;
        break;
    }
    i++;
  }
  if (state === 2 /* dynamic */)
    throw new Error(`Unfinished param "${buffer}"`);
  consumeBuffer();
  return tokens;
}
function prepareRoutes(routes, parent) {
  for (const route of routes) {
    if (route.name)
      route.name = route.name.replace(/-index$/, "");
    if (parent && route.path.startsWith("/"))
      route.path = route.path.slice(1);
    if (route.children?.length)
      route.children = prepareRoutes(route.children, route);
    if (route.children?.find((childRoute) => childRoute.path === ""))
      delete route.name;
  }
  return routes;
}

const module = defineNuxtModule({
  meta: {
    name: "nuxt-simple-sitemap",
    compatibility: {
      nuxt: "^3.0.0",
      bridge: false
    },
    configKey: "sitemap"
  },
  defaults(nuxt) {
    const trailingSlash = process.env.NUXT_PUBLIC_TRAILING_SLASH || nuxt.options.runtimeConfig.public.trailingSlash;
    return {
      include: ["/**"],
      hostname: process.env.NUXT_PUBLIC_SITE_URL || nuxt.options.runtimeConfig.public?.siteUrl,
      // false by default
      trailingSlash: typeof trailingSlash !== "undefined" ? trailingSlash : false,
      enabled: true,
      urls: [],
      defaults: {},
      devPreview: true,
      inferStaticPagesAsRoutes: true
    };
  },
  async setup(config, nuxt) {
    const { resolve } = createResolver(import.meta.url);
    addTemplate({
      filename: "nuxt-simple-sitemap.d.ts",
      getContents: () => {
        return `// Generated by nuxt-simple-sitemap
import type { SitemapItemLoose } from 'sitemap'

type SitemapEntry = SitemapItemLoose & {
  changefreq?: 'always' | 'hourly' | 'daily' | 'weekly' | 'monthly' | 'yearly' | 'never' | (string & Record<never, never>)
}

interface NuxtSimpleSitemapNitroRules {
  index?: boolean
  sitemap?: SitemapEntry
}
declare module 'nitropack' {
  interface NitroRouteRules extends NuxtSimpleSitemapNitroRules {}
  interface NitroRouteConfig extends NuxtSimpleSitemapNitroRules {}
}
export {}
`;
      }
    });
    nuxt.hooks.hook("prepare:types", ({ references }) => {
      references.push({ path: resolve(nuxt.options.buildDir, "nuxt-simple-sitemap.d.ts") });
    });
    if (nuxt.options._prepare)
      return;
    const fixUrl = (url) => withBase(nuxt.options.sitemap?.trailingSlash ? withTrailingSlash(url) : withoutTrailingSlash(url), nuxt.options.app.baseURL);
    function normaliseUrls(urls2) {
      return uniqueBy(
        urls2.map((url) => typeof url === "string" ? { url } : url).map((url) => ({ ...config.defaults, ...url })).map((url) => ({ ...url, url: fixUrl(url.url) })),
        "url"
      ).sort((a, b) => a.url.length - b.url.length);
    }
    const prerendedRoutes = [];
    const urlFilter = createFilter(config);
    async function generateUrls() {
      let urls2 = [];
      if (!config.inferStaticPagesAsRoutes)
        return urls2;
      if (typeof config.urls === "function")
        urls2 = [...await config.urls()];
      else if (Array.isArray(config.urls))
        urls2 = [...await config.urls];
      const pages = await resolvePagesRoutes();
      pages.forEach((page) => {
        if (!page.path.includes(":") && urlFilter(page.path)) {
          urls2.push({
            url: page.path
          });
        }
      });
      return normaliseUrls(urls2);
    }
    if (nuxt.options.dev) {
      let urls2 = ["/"];
      if (config.devPreview) {
        urls2 = await generateUrls();
        addServerHandler({
          route: "/sitemap.xml",
          handler: resolve("./runtime/sitemap.xml")
        });
        addServerHandler({
          route: "/sitemap.preview.xml",
          handler: resolve("./runtime/sitemap.preview.xml")
        });
      }
      exposeModuleConfig("nuxt-simple-sitemap", {
        ...config,
        urls: urls2
      });
      return;
    }
    const urls = await generateUrls();
    nuxt.hooks.hook("nitro:init", async (nitro) => {
      const logger = useLogger("nuxt-simple-sitemap");
      if (!config.hostname) {
        logger.warn("Please set a `hostname` on the `sitemap` config to use `nuxt-simple-sitemap`.");
        return;
      }
      if (!config.enabled) {
        logger.warn("Sitemap generation is disabled. Set `sitemap.enabled` to `true` to enable it.");
        return;
      }
      let sitemapGenerate = false;
      const outputSitemap = async () => {
        if (sitemapGenerate)
          return;
        const start = Date.now();
        const _routeRulesMatcher = toRouteMatcher(
          createRouter({ routes: nitro.options.routeRules })
        );
        const stream = new SitemapStream(config);
        const sitemapUrls = uniqueBy(
          normaliseUrls([...urls, ...prerendedRoutes]).filter((entry) => urlFilter(entry.url)).map((entry) => {
            const url = entry.url;
            const routeRules = defu({}, ..._routeRulesMatcher.matchAll(withoutBase(withoutTrailingSlash(url), nuxt.options.app.baseURL)).reverse());
            if (routeRules.index === false)
              return false;
            return { ...config.defaults, ...entry, ...routeRules.sitemap || {} };
          }).filter(Boolean),
          "url"
        );
        const sitemapContext = { stream, urls: sitemapUrls };
        await nuxt.hooks.callHook("sitemap:generate", sitemapContext);
        if (sitemapContext.urls.length === 0)
          return;
        const sitemapXml = await streamToPromise(Readable.from(sitemapContext.urls).pipe(sitemapContext.stream)).then((data) => data.toString());
        await writeFile(resolve(nitro.options.output.publicDir, "sitemap.xml"), sitemapXml);
        const generateTimeMS = Date.now() - start;
        nitro.logger.log(chalk.gray(
          `  \u2514\u2500 /sitemap.xml (${generateTimeMS}ms)`
        ));
        sitemapGenerate = true;
      };
      nitro.hooks.hook("prerender:route", async ({ route }) => {
        if (!route.includes(".")) {
          prerendedRoutes.push({ url: route });
        }
      });
      nitro.hooks.hook("rollup:before", async () => {
        await outputSitemap();
      });
      nitro.hooks.hook("close", async () => {
        await outputSitemap();
      });
    });
  }
});

export { module as default };
