import{createSSRApp as t}from"vue";import"./vue-compat/index-vue3.js";import{warn as e}from"./warn.js";import r from"instantsearch.js/es/index.js";import{waitForResults as n,getInitialResults as s}from"instantsearch.js/es/lib/server.js";function o(e,r){void 0===r&&(r={});var n=r.mixins;void 0===n&&(n=[]);var s,o={serverPrefetch:void 0,fetch:void 0,_base:void 0,name:"ais-ssr-root-component"},i=Object.assign({},e.$options,o);return i.mixins=n.concat(i.mixins||[]),s=t(i),e.$router&&s.use(e.$router),e.$store&&s.use(e.$store),s.$slots=e.$slots,s.$root=e.$root,s}function i(t){void 0===t&&(t={});var i=t.$cloneComponent;void 0===i&&(i=o);var a=function(t,o){var i,a=r(t);return a.findResultsState=function(t){var e,r,u=t.component,c=t.renderToString;if(!c)throw new Error("findResultsState requires `renderToString: (component) => Promise<string>` in the first argument.");return Promise.resolve().then(function(){e=o(u,{mixins:[{beforeCreate:function(){var t=Object.getOwnPropertyDescriptor(u,"$nuxt"),e=!!t&&(t.writable||t.set);u.$nuxt&&e&&(this.$nuxt=u.$nuxt)},created:function(){(r=this.instantsearch).start(),r.started=!1}}]})}).then(function(){return c(e)}).then(function(){return n(r)}).then(function(){return i=s(r.mainIndex),a.hydrate(i),a.getState()})},a.getState=function(){if(!i)throw new Error("You need to wait for findResultsState to finish");return i},a.__forceRender=function(t,e){var r=e.getResults();if(null!==r){var n=r._state,s=e.getHelper();s.state=n,t.render({helper:s,results:r,scopedResults:e.getScopedResults(),parent:e,state:n,templatesConfig:{},createURL:e.createURL,instantSearchInstance:a,searchMetadata:{isSearchStalled:!1}})}},a.hydrate=function(t){t?(a._initialResults=t,a.start(),a.started=!1):e("The result of `findResultsState()` needs to be passed to `hydrate()`.")},a}(t,i);return{provide:function(){return{$_ais_ssrInstantSearchInstance:this.instantsearch}},data:function(){return{instantsearch:a}}}}export{i as createServerRootMixin};
//# sourceMappingURL=createServerRootMixin.js.map
