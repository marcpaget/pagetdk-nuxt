import { readFile, writeFile } from 'node:fs/promises';
import { useNuxt, addTemplate, defineNuxtModule, createResolver, addServerHandler, addImports, addComponent } from '@nuxt/kit';
import { execa } from 'execa';
import chalk from 'chalk';
import defu from 'defu';
import { toRouteMatcher, createRouter } from 'radix3';
import { joinURL } from 'ufo';
import { resolve, relative } from 'pathe';
import { tinyws } from 'tinyws';
import sirv from 'sirv';
import { pathExists, copy, mkdirp } from 'fs-extra';
import { provider } from 'std-env';
import playwrightCore from 'playwright-core';
import { existsSync } from 'node:fs';
import { createBirpcGroup } from 'birpc';
import { stringify, parse } from 'flatted';

async function createBrowser() {
  try {
    const { Launcher } = await import(String("chrome-launcher"));
    const chromePath = Launcher.getFirstInstallation();
    return await playwrightCore.chromium.launch({
      headless: true,
      executablePath: chromePath
    });
  } catch (e) {
  }
  try {
    return await playwrightCore.chromium.launch({
      headless: true
    });
  } catch (e) {
  }
  try {
    const playwright = await import(String("playwright"));
    return await playwright.chromium.launch({
      headless: true
    });
  } catch (e) {
    if (process.dev) {
      console.warn("Failed to load chromium instance. Ensure you have chrome installed, otherwise add the dependency: `npm add -D playwright`.");
    } else {
      console.error("Failed to load browser instance. Please open an issue with the exception: https://github.com/harlan-zw/nuxt-og-image/issues.");
      throw e;
    }
  }
}

async function screenshot(browser, options) {
  const page = await browser.newPage({
    colorScheme: options.colorScheme
  });
  await page.setViewportSize({
    width: options.width || 1200,
    height: options.height || 630
  });
  if (options.path.startsWith("html:")) {
    await page.evaluate((html) => {
      document.open("text/html");
      document.write(html);
      document.close();
    }, options.path.substring(5));
    await page.waitForLoadState("networkidle");
  } else {
    await page.goto(`${options.host}${options.path}`, {
      timeout: 1e4,
      waitUntil: "networkidle"
    });
  }
  if (options.delay)
    await page.waitForTimeout(options.delay);
  if (options.mask) {
    await page.evaluate((mask) => {
      for (const el of document.querySelectorAll(mask))
        el.style.display = "none";
    }, options.mask);
  }
  if (options.selector)
    return await page.locator(options.selector).screenshot();
  return await page.screenshot();
}

function setupPlaygroundRPC(nuxt, config) {
  const serverFunctions = {
    getConfig() {
      return config;
    },
    async openInEditor(input) {
      if (input.startsWith("./"))
        input = resolve(process.cwd(), input);
      const match = input.match(/^(.*?)([:\d]*)$/);
      let suffix = "";
      if (match) {
        input = match[1];
        suffix = match[2];
      }
      const file = [
        input,
        `${input}.js`,
        `${input}.mjs`,
        `${input}.ts`
      ].find((i) => existsSync(i));
      if (file) {
        await import('launch-editor').then((r) => (r.default || r)(file + suffix));
      } else {
        console.error("File not found:", input);
      }
    }
  };
  const clients = /* @__PURE__ */ new Set();
  const birpc = createBirpcGroup(serverFunctions, []);
  nuxt.hook("builder:watch", (e, path) => {
    if (e === "change")
      birpc.boardcast.refresh.asEvent(path);
  });
  const middleware = async (req, res) => {
    if (req.ws) {
      const ws = await req.ws();
      clients.add(ws);
      const channel = {
        post: (d) => ws.send(d),
        on: (fn) => ws.on("message", fn),
        serialize: stringify,
        deserialize: parse
      };
      birpc.updateChannels((c) => {
        c.push(channel);
      });
      ws.on("close", () => {
        clients.delete(ws);
        birpc.updateChannels((c) => {
          const index = c.indexOf(channel);
          if (index >= 0)
            c.splice(index, 1);
        });
      });
    } else if (req.method === "POST") {
      const body = await getBodyJson(req);
      if (body.method === "setPayload") ; else {
        res.statusCode = 400;
      }
      res.end();
    }
  };
  return {
    middleware,
    birpc
  };
}
function getBodyJson(req) {
  return new Promise((resolve2, reject) => {
    let body = "";
    req.on("data", (chunk) => body += chunk);
    req.on("error", reject);
    req.on("end", () => {
      try {
        resolve2(JSON.parse(body) || {});
      } catch (e) {
        reject(e);
      }
    });
  });
}

function exposeModuleConfig(moduleName, config) {
  const nuxt = useNuxt();
  const jsExports = Object.entries(config).map(([k, v]) => `export const ${k} = ${JSON.stringify(v)}`).join("\n");
  const alias = `#${moduleName}/config`;
  nuxt.options.alias[alias] = addTemplate({
    filename: `modules/config/${moduleName}.mjs`,
    getContents: () => jsExports
  }).dst;
  nuxt.hooks.hook("nitro:config", (nitroConfig) => {
    nitroConfig.virtual[alias] = jsExports;
  });
  const typeDefName = `modules/config/${moduleName}.d.ts`;
  const tsExports = Object.keys(config).map((k) => {
    if (nuxt.options.dev)
      return `  export const ${k}: ${JSON.stringify(config[k])} | ModuleOptions['${k}']`;
    return `  export const ${k}: ModuleOptions['${k}']`;
  }).join("\n");
  addTemplate({
    filename: typeDefName,
    getContents: () => {
      return `// generated by ${moduleName}
import type { ModuleOptions } from '${moduleName}'
declare module '${alias}' {
${tsExports}
}
`;
    }
  });
  nuxt.hooks.hook("prepare:types", ({ references }) => {
    references.push({ path: resolve(nuxt.options.buildDir, typeDefName) });
  });
  return alias;
}

function decodeHtmlEntities(obj) {
  Object.entries(obj).forEach(([key, value]) => {
    if (typeof value === "string") {
      obj[key] = value.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&").replace(/&quot;/g, '"').replace(/&#x27;/g, "'").replace(/&#x2F;/g, "/");
    }
  });
  return obj;
}
function extractOgImageOptions(html) {
  const htmlPayload = html.match(/<script id="nuxt-og-image-options" type="application\/json">(.+?)<\/script>/)?.[1];
  if (!htmlPayload)
    return false;
  let options;
  try {
    options = JSON.parse(htmlPayload);
  } catch (e) {
    options = false;
    if (process.dev)
      console.warn("Failed to parse #nuxt-og-image-options", e, options);
  }
  if (options) {
    const description = html.match(/<meta property="og:description" content="(.*?)">/)?.[1];
    if (description)
      options.description = description;
    else
      options.description = html.match(/<meta name="description" content="(.*?)">/)?.[1];
    return decodeHtmlEntities(options);
  }
  return false;
}
function stripOgImageOptions(html) {
  return html.replace(/<script id="nuxt-og-image-options" type="application\/json">(.*?)<\/script>/, "");
}

const PATH = "/__nuxt_og_image__";
const PATH_ENTRY = `${PATH}/entry`;
const PATH_PLAYGROUND = `${PATH}/client`;
const edgeProvidersSupported = [
  "cloudflare",
  "vercel-edge",
  "netlify-edge"
];
const module = defineNuxtModule({
  meta: {
    name: "nuxt-og-image",
    compatibility: {
      nuxt: "^3.2.0",
      bridge: false
    },
    configKey: "ogImage"
  },
  defaults(nuxt) {
    return {
      // when we run `nuxi generate` we need to force prerendering
      forcePrerender: !nuxt.options.dev && nuxt.options._generate,
      host: process.env.NUXT_PUBLIC_SITE_URL || nuxt.options.runtimeConfig.public?.siteUrl,
      defaults: {
        component: "OgImageBasic",
        width: 1200,
        height: 630
      },
      satoriProvider: true,
      browserProvider: true,
      fonts: [],
      satoriOptions: {},
      experimentalInlineWasm: process.env.NITRO_PRESET === "netlify-edge" || nuxt.options.nitro.preset === "netlify-edge" || false,
      experimentalRuntimeBrowser: false,
      playground: process.env.NODE_ENV === "development" || nuxt.options.dev
    };
  },
  async setup(config, nuxt) {
    const { resolve } = createResolver(import.meta.url);
    if (!config.fonts.length)
      config.fonts = ["Inter:400", "Inter:700"];
    const distResolve = (p) => {
      const cwd = resolve(".");
      if (cwd.endsWith("/dist"))
        return resolve(p);
      return resolve(`../dist/${p}`);
    };
    nuxt.options.experimental.componentIslands = true;
    addTemplate({
      filename: "nuxt-og-image.d.ts",
      getContents: () => {
        return `// Generated by nuxt-og-image
interface NuxtOgImageNitroRules {
  ogImage?: false | Record<string, any>
}
declare module 'nitropack' {
  interface NitroRouteRules extends NuxtOgImageNitroRules {}
  interface NitroRouteConfig extends NuxtOgImageNitroRules {}
}
export {}
`;
      }
    });
    nuxt.hooks.hook("prepare:types", ({ references }) => {
      references.push({ path: resolve(nuxt.options.buildDir, "nuxt-og-image.d.ts") });
    });
    addServerHandler({
      lazy: true,
      handler: resolve("./runtime/nitro/middleware/og.png")
    });
    ["html", "options", "svg", "vnode", "font"].forEach((type) => {
      addServerHandler({
        lazy: true,
        route: `/api/og-image-${type}`,
        handler: resolve(`./runtime/nitro/routes/${type}`)
      });
    });
    nuxt.hook("devtools:customTabs", (iframeTabs) => {
      iframeTabs.push({
        name: "ogimage",
        title: "OG Image",
        icon: "carbon:image-search",
        view: {
          type: "iframe",
          src: "/__nuxt_og_image__/client/"
        }
      });
    });
    if (config.playground) {
      const playgroundDir = distResolve("./client");
      const {
        middleware: rpcMiddleware
      } = setupPlaygroundRPC(nuxt, config);
      nuxt.hook("vite:serverCreated", async (server) => {
        server.middlewares.use(PATH_ENTRY, tinyws());
        server.middlewares.use(PATH_ENTRY, rpcMiddleware);
        if (await pathExists(playgroundDir))
          server.middlewares.use(PATH_PLAYGROUND, sirv(playgroundDir, { single: true, dev: true }));
      });
      addServerHandler({
        handler: resolve("./runtime/nitro/middleware/playground")
      });
    }
    ["defineOgImageDynamic", "defineOgImageStatic", "defineOgImageScreenshot"].forEach((name) => {
      addImports({
        name,
        from: resolve("./runtime/composables/defineOgImage")
      });
    });
    await addComponent({
      name: "OgImageBasic",
      filePath: resolve("./runtime/components/OgImageBasic.island.vue"),
      island: true
    });
    ["OgImageStatic", "OgImageDynamic", "OgImageScreenshot"].forEach((name) => {
      addComponent({
        name,
        filePath: resolve(`./runtime/components/${name}`)
      });
    });
    const runtimeDir = resolve("./runtime");
    nuxt.options.build.transpile.push(runtimeDir);
    const moduleAssetDir = resolve("./runtime/public-assets");
    const assetDirs = [
      resolve(nuxt.options.rootDir, nuxt.options.dir.public),
      moduleAssetDir
    ];
    exposeModuleConfig("nuxt-og-image", { ...config, assetDirs });
    const useSatoriWasm = provider === "stackblitz";
    nuxt.hooks.hook("nitro:config", async (nitroConfig) => {
      nitroConfig.externals = defu(nitroConfig.externals || {}, {
        inline: [runtimeDir]
      });
      if (config.experimentalRuntimeBrowser) {
        nitroConfig.alias = nitroConfig.alias || {};
        nitroConfig.alias.electron = "unenv/runtime/mock/proxy-cjs";
        nitroConfig.alias.bufferutil = "unenv/runtime/mock/proxy-cjs";
        nitroConfig.alias["utf-8-validate"] = "unenv/runtime/mock/proxy-cjs";
      }
      nitroConfig.publicAssets = nitroConfig.publicAssets || [];
      nitroConfig.publicAssets.push({ dir: moduleAssetDir, maxAge: 31536e3 });
      const providerPath = `${runtimeDir}/nitro/providers`;
      if (config.browserProvider) {
        nitroConfig.virtual["#nuxt-og-image/browser"] = nuxt.options.dev || config.experimentalRuntimeBrowser ? `
import node from '${providerPath}/browser/node'

export default async function() {
  return node
}
` : `export default async function() {
 return () => {}
}
`;
      }
      if (config.satoriProvider) {
        nitroConfig.virtual["#nuxt-og-image/satori"] = `import satori from '${providerPath}/satori/${useSatoriWasm ? "webworker" : "node"}'
export default async function() {
  return satori
}`;
        nitroConfig.virtual["#nuxt-og-image/svg2png"] = `
import svg2png from '${providerPath}/svg2png/universal'
export default async function() {
 return svg2png
}`;
      }
      nitroConfig.virtual["#nuxt-og-image/provider"] = `
import satori from '${relative(nuxt.options.rootDir, resolve("./runtime/nitro/renderers/satori"))}'
import browser from '${relative(nuxt.options.rootDir, resolve("./runtime/nitro/renderers/browser"))}'

export async function useProvider(provider) {
  if (provider === 'satori')
    return satori
  if (provider === 'browser')
    return browser
}
      `;
    });
    nuxt.hooks.hook("nitro:init", async (nitro) => {
      let screenshotQueue = [];
      nitro.hooks.hook("compiled", async (_nitro) => {
        if (edgeProvidersSupported.includes(_nitro.options.preset)) {
          await copy(resolve("./runtime/public-assets/inter-latin-ext-400-normal.woff"), resolve(_nitro.options.output.publicDir, "inter-latin-ext-400-normal.woff"));
          await copy(resolve("./runtime/public-assets/inter-latin-ext-700-normal.woff"), resolve(_nitro.options.output.publicDir, "inter-latin-ext-700-normal.woff"));
          if (!config.experimentalInlineWasm) {
            await copy(resolve("./runtime/public-assets/svg2png.wasm"), resolve(_nitro.options.output.serverDir, "svg2png.wasm"));
            if (useSatoriWasm)
              await copy(resolve("./runtime/public-assets/yoga.wasm"), resolve(_nitro.options.output.serverDir, "yoga.wasm"));
          }
          const indexFile = resolve(_nitro.options.output.serverDir, _nitro.options.preset === "netlify-edge" ? "server.mjs" : "index.mjs");
          if (await pathExists(indexFile)) {
            const indexContents = (await readFile(indexFile, "utf-8")).replace(".cwd(),", '?.cwd || "/",');
            if (!config.experimentalInlineWasm) {
              await writeFile(
                indexFile,
                indexContents.replace('"/* NUXT_OG_IMAGE_SVG2PNG_WASM */"', 'import("./svg2png.wasm").then(m => m.default || m)').replace('"/* NUXT_OG_IMAGE_YOGA_WASM */"', 'import("./yoga.wasm").then(m => m.default || m)')
              );
            } else {
              const svg2pngWasm = await readFile(resolve("./runtime/public-assets/svg2png.wasm"), "base64");
              const yogaWasm = await readFile(resolve("./runtime/public-assets/yoga.wasm"), "base64");
              await writeFile(
                indexFile,
                indexContents.replace('"/* NUXT_OG_IMAGE_SVG2PNG_WASM */"', `Buffer.from("${svg2pngWasm}", "base64")`).replace('"/* NUXT_OG_IMAGE_YOGA_WASM */"', `Buffer.from("${yogaWasm}", "base64")`)
              );
            }
          }
        }
      });
      const _routeRulesMatcher = toRouteMatcher(
        createRouter({ routes: nitro.options.routeRules })
      );
      nitro.hooks.hook("prerender:generate", async (ctx) => {
        if (ctx.route.includes("."))
          return;
        const html = ctx.contents;
        if (!html)
          return;
        const extractedOptions = extractOgImageOptions(html);
        ctx.contents = stripOgImageOptions(html);
        const routeRules = defu({}, ..._routeRulesMatcher.matchAll(ctx.route).reverse());
        if (!extractedOptions || routeRules.ogImage === false)
          return;
        const entry = {
          path: extractedOptions.component ? `/api/og-image-html?path=${ctx.route}` : ctx.route,
          ...extractedOptions,
          ...routeRules.ogImage || {},
          ctx
        };
        if (entry.component)
          entry.path = `html:${await $fetch(entry.path)}`;
        if ((nuxt.options._generate || entry.static) && entry.provider === "browser")
          screenshotQueue.push(entry);
      });
      if (nuxt.options.dev)
        return;
      const captureScreenshots = async () => {
        if (screenshotQueue.length === 0)
          return;
        nitro.logger.info("Ensuring chromium install for og:image generation...");
        const installChromeProcess = execa("npx", ["playwright", "install", "chromium"], {
          stdio: "inherit"
        });
        installChromeProcess.stderr?.pipe(process.stderr);
        await new Promise((resolve2) => {
          installChromeProcess.on("exit", (e) => {
            if (e !== 0)
              nitro.logger.error("Failed to install Playwright dependency for og:image generation. Trying anyway...");
            resolve2(true);
          });
        });
        const previewProcess = execa("npx", ["serve", nitro.options.output.publicDir]);
        let browser = null;
        try {
          previewProcess.stderr?.pipe(process.stderr);
          const host = (await new Promise((resolve2) => {
            previewProcess.stdout?.on("data", (data) => {
              if (data.includes("Accepting connections at")) {
                resolve2(data.toString().split("Accepting connections at ")[1]);
              }
            });
          })).trim();
          browser = await createBrowser();
          if (browser) {
            nitro.logger.info(`Prerendering ${screenshotQueue.length} og:image screenshots...`);
            for (const k in screenshotQueue) {
              const entry = screenshotQueue[k];
              const start = Date.now();
              let hasError = false;
              const dirname = joinURL(nitro.options.output.publicDir, `${entry.ctx.fileName.replace("index.html", "")}__og_image__/`);
              const filename = joinURL(dirname, "/og.png");
              try {
                const imgBuffer = await screenshot(browser, {
                  ...config.defaults || {},
                  ...entry || {},
                  host
                });
                try {
                  await mkdirp(dirname);
                } catch (e) {
                }
                await writeFile(filename, imgBuffer);
              } catch (e) {
                hasError = true;
                console.error(e);
              }
              const generateTimeMS = Date.now() - start;
              nitro.logger.log(chalk[hasError ? "red" : "gray"](
                `  ${Number(k) === screenshotQueue.length - 1 ? "\u2514\u2500" : "\u251C\u2500"} ${relative(nitro.options.output.publicDir, filename)} (${generateTimeMS}ms) ${Math.round((Number(k) + 1) / screenshotQueue.length * 100)}%`
              ));
            }
          } else {
            nitro.logger.log(chalk.red("Failed to create a browser to create og:images."));
          }
        } catch (e) {
          console.error(e);
        } finally {
          await browser?.close();
          previewProcess.kill();
        }
        screenshotQueue = [];
      };
      nitro.hooks.hook("rollup:before", async () => {
        await captureScreenshots();
      });
      nitro.hooks.hook("close", async () => {
        await captureScreenshots();
      });
    });
  }
});

export { module as default };
