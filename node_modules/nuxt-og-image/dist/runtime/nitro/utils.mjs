import { existsSync, promises as fsp } from "node:fs";
import { getHeaders, getQuery, getRequestHeader } from "h3";
import { join } from "pathe";
import { assetDirs } from "#nuxt-og-image/config";
import { useRuntimeConfig } from "#internal/nitro";
export function wasmLoader(key, fallback, baseUrl) {
  let promise;
  let loaded = false;
  return {
    loaded() {
      if (loaded)
        return true;
      if (typeof promise !== "undefined")
        return promise;
      return false;
    },
    async load() {
      promise = promise || new Promise(async (resolve) => {
        let wasm;
        try {
          wasm = await key;
          if (typeof wasm === "string")
            wasm = void 0;
        } catch (e) {
        }
        if (!wasm)
          wasm = await readPublicAsset(fallback);
        if (!wasm) {
          const url = new URL(baseUrl);
          wasm = await (await fetch(`${url.origin}${fallback}`)).arrayBuffer();
        }
        loaded = true;
        resolve(wasm);
      });
      return promise;
    }
  };
}
export function fetchOptions(e, path) {
  const fetchOptions2 = process.dev || process.env.prerender ? {
    headers: getHeaders(e)
  } : {
    baseURL: useHostname(e)
  };
  return globalThis.$fetch("/api/og-image-options", {
    query: {
      ...getQuery(e),
      path
    },
    ...fetchOptions2
  });
}
export function base64ToArrayBuffer(base64) {
  const buffer = Buffer.from(base64, "base64");
  return new Uint8Array(buffer).buffer;
}
export function renderIsland(payload) {
  return globalThis.$fetch(`/__nuxt_island/${payload.component}`, {
    query: { props: JSON.stringify(payload) }
  });
}
export function useHostname(e) {
  const host = getRequestHeader(e, "host") || process.env.NITRO_HOST || process.env.HOST || "localhost";
  const protocol = getRequestHeader(e, "x-forwarded-proto") || "http";
  const useHttp = process.env.NODE_ENV === "development" || host.includes("127.0.0.1") || host.includes("localhost") || protocol === "http";
  const port = host.includes(":") ? host.split(":").pop() : process.env.NITRO_PORT || process.env.PORT;
  const base = useRuntimeConfig().app.baseURL;
  return `http${useHttp ? "" : "s"}://${host.includes(":") ? host.split(":")[0] : host}${port ? `:${port}` : ""}${base}`;
}
const r = (base, key) => {
  return join(base, key.replace(/:/g, "/"));
};
export async function readPublicAsset(file, encoding) {
  for (const assetDir of assetDirs) {
    const path = r(assetDir, file);
    if (existsSync(path))
      return await fsp.readFile(path, { encoding });
  }
}
export async function readPublicAssetBase64(file) {
  const base64 = await readPublicAsset(file, "base64");
  if (base64) {
    let type = "image/jpeg";
    const ext = file.split(".").pop();
    if (ext === "svg")
      type = "image/svg+xml";
    else if (ext === "png")
      type = "image/png";
    return `data:${type};base64,${base64}`;
  }
}
export * from "./utils-pure.mjs";
