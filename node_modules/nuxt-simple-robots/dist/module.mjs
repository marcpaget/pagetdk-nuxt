import { useNuxt, addTemplate, defineNuxtModule, createResolver, useLogger, addImports, addComponent, addServerHandler } from '@nuxt/kit';
import { withBase } from 'ufo';
import { resolve } from 'pathe';

function exposeModuleConfig(moduleName, config) {
  const nuxt = useNuxt();
  const jsExports = Object.entries(config).map(([k, v]) => `export const ${k} = ${JSON.stringify(v)}`).join("\n");
  const alias = `#${moduleName}/config`;
  nuxt.options.alias[alias] = addTemplate({
    filename: `modules/config/${moduleName}.mjs`,
    getContents: () => jsExports
  }).dst;
  nuxt.hooks.hook("nitro:config", (nitroConfig) => {
    nitroConfig.virtual[alias] = jsExports;
  });
  const typeDefName = `modules/config/${moduleName}.d.ts`;
  const tsExports = Object.keys(config).map((k) => {
    if (nuxt.options.dev)
      return `  export const ${k}: ${JSON.stringify(config[k])} | ModuleOptions['${k}']`;
    return `  export const ${k}: ModuleOptions['${k}']`;
  }).join("\n");
  addTemplate({
    filename: typeDefName,
    getContents: () => {
      return `// generated by ${moduleName}
import type { ModuleOptions } from '${moduleName}'
declare module '${alias}' {
${tsExports}
}
`;
    }
  });
  nuxt.hooks.hook("prepare:types", ({ references }) => {
    references.push({ path: resolve(nuxt.options.buildDir, typeDefName) });
  });
  return alias;
}

const module = defineNuxtModule({
  meta: {
    name: "nuxt-simple-robots",
    compatibility: {
      nuxt: "^3.0.0",
      bridge: false
    },
    configKey: "robots"
  },
  defaults(nuxt) {
    let indexable = true;
    if (typeof process.env.NUXT_INDEXABLE !== "undefined")
      indexable = String(process.env.NUXT_INDEXABLE) !== "false";
    else if (typeof nuxt.options.runtimeConfig.indexable !== "undefined")
      indexable = String(nuxt.options.runtimeConfig.indexable) !== "false";
    else if (process.env.NODE_ENV !== "production")
      indexable = false;
    return {
      enabled: true,
      host: process.env.NUXT_PUBLIC_SITE_URL || process.env.NUXT_SITE_URL || nuxt.options.runtimeConfig.public?.siteUrl || nuxt.options.runtimeConfig.siteUrl,
      disallow: [],
      sitemap: [],
      indexable,
      robotsEnabledValue: "index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1",
      robotsDisabledValue: "noindex, nofollow"
    };
  },
  async setup(config, nuxt) {
    if (config.enabled === false)
      return;
    const { resolve } = createResolver(import.meta.url);
    config.indexable = String(config.indexable) !== "false";
    const logger = useLogger("nuxt-simple-robots");
    if (typeof config.sitemap !== "undefined") {
      if (typeof config.sitemap === "string")
        config.sitemap = [config.sitemap];
      for (const k in config.sitemap) {
        const sitemap = config.sitemap[k];
        if (!sitemap.startsWith("http")) {
          if (config.host) {
            config.sitemap[k] = withBase(sitemap, config.host);
          } else {
            config.sitemap.splice(Number(k), 1);
            logger.error(`Ignoring robots.txt entry ${sitemap}, sitemap must be absolute.
Please provide "host" or make the link absolute, for example: https://example.com${sitemap}.`);
          }
        }
      }
    }
    addTemplate({
      filename: "nuxt-simple-robots.d.ts",
      getContents: () => {
        return `// Generated by nuxt-simple-robots
interface NuxtSimpleRobotsNitroRules {
  index?: boolean
  robots?: string
}
declare module 'nitropack' {
  interface NitroRouteRules extends NuxtSimpleRobotsNitroRules {}
  interface NitroRouteConfig extends NuxtSimpleRobotsNitroRules {}
}
export {}
`;
      }
    });
    nuxt.hooks.hook("prepare:types", ({ references }) => {
      references.push({ path: resolve(nuxt.options.buildDir, "nuxt-simple-robots.d.ts") });
    });
    nuxt.hooks.hook("nitro:init", async (nitro) => {
      nitro.options.prerender.routes = nitro.options.prerender.routes || [];
      nitro.options.prerender.routes.push("/robots.txt");
    });
    exposeModuleConfig("nuxt-simple-robots", config);
    addImports({
      name: "defineRobotMeta",
      from: resolve("./runtime/composables/defineRobotMeta")
    });
    await addComponent({
      name: "RobotMeta",
      filePath: resolve("./runtime/components/RobotMeta")
    });
    addServerHandler({
      route: "/robots.txt",
      handler: resolve("./runtime/server/robots-route")
    });
    addServerHandler({
      handler: resolve("./runtime/server/robots-middleware")
    });
  }
});

export { module as default };
