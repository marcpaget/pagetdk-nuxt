import { computed } from "vue-demi";
const COOKIE_EXPIRES_IN_DAYS = 365 * 24 * 60 * 60 * 1e3;
export const DEFAULT_OPTIONS = {
  breakpoints: {
    desktop: 1024,
    desktopMedium: 1280,
    desktopWide: 1600,
    mobile: 320,
    mobileMedium: 375,
    mobileWide: 425,
    tablet: 768
  },
  cookieName: "viewport",
  defaultBreakpoints: {
    desktop: "desktop",
    mobile: "mobile",
    tablet: "tablet"
  },
  fallbackBreakpoint: "desktop"
};
export const STATE_KEY = "viewportState";
export function createViewportManager(options, state) {
  const queries = computed(() => {
    const breakpoints = options.breakpoints || {};
    const breakpointsKeys = Object.keys(breakpoints).sort((a, b) => breakpoints[a] - breakpoints[b]);
    const output = {};
    let i = breakpointsKeys.length;
    while (i--) {
      const currentKey = breakpointsKeys[i];
      const size = breakpoints[currentKey];
      const nextSize = breakpoints[breakpointsKeys[i + 1]];
      let mediaQuery = "";
      if (i > 0) {
        mediaQuery = `(min-width: ${size}px)`;
      } else {
        mediaQuery = "(min-width: 1px)";
      }
      if (nextSize) {
        mediaQuery += ` and (max-width: ${nextSize - 1}px)`;
      }
      output[currentKey] = {
        mediaQuery,
        size
      };
    }
    return output;
  });
  const breakpoint = computed({
    get() {
      return state.value || options.fallbackBreakpoint;
    },
    set(newBreakpoint) {
      state.value = newBreakpoint;
      if (options.cookieName && typeof window !== "undefined") {
        const date = new Date();
        date.setTime(date.getTime() + COOKIE_EXPIRES_IN_DAYS);
        document.cookie = `${options.cookieName}=${state.value}; SameSite=Strict; Secure; Expires=${date.toUTCString()}; Path=/`;
      }
    }
  });
  return {
    breakpoint,
    isGreaterThan,
    isGreaterOrEquals,
    isLessThan,
    match,
    matches,
    queries
  };
  function isGreaterThan(searchBreakpoint) {
    const keys = Object.keys(queries.value);
    const currentIndex = keys.indexOf(breakpoint.value);
    const breakpointIndex = keys.indexOf(searchBreakpoint);
    if (breakpointIndex === -1) {
      return false;
    }
    return breakpointIndex > currentIndex;
  }
  function isGreaterOrEquals(searchBreakpoint) {
    return isGreaterThan(searchBreakpoint) || match(searchBreakpoint);
  }
  function isLessThan(searchBreakpoint) {
    const keys = Object.keys(queries.value);
    const currentIndex = keys.indexOf(breakpoint.value);
    const breakpointIndex = keys.indexOf(searchBreakpoint);
    if (breakpointIndex === -1) {
      return false;
    }
    return breakpointIndex < currentIndex;
  }
  function match(breakpointToMatch) {
    return breakpoint.value === breakpointToMatch;
  }
  function matches(...breakpointsToMatch) {
    return breakpointsToMatch.includes(breakpoint.value);
  }
}
