import { deleteCookie, eventHandler, parseCookies, setCookie } from "h3";
import { nanoid } from "nanoid";
import dayjs from "dayjs";
import { dropStorageSession, getStorageSession, setStorageSession } from "./storage.mjs";
import { processSessionIp, getHashedIpAddress } from "./ipPinning.mjs";
import { SessionExpired } from "./exceptions.mjs";
import { useRuntimeConfig } from "#imports";
const SESSION_COOKIE_NAME = "sessionId";
const safeSetCookie = (event, name, value, createdAt) => {
  const sessionOptions = useRuntimeConfig().session.session;
  const expirationDate = sessionOptions.expiryInSeconds !== false ? new Date(createdAt.getTime() + sessionOptions.expiryInSeconds * 1e3) : void 0;
  setCookie(event, name, value, {
    expires: expirationDate,
    secure: sessionOptions.cookieSecure,
    httpOnly: sessionOptions.cookieHttpOnly,
    sameSite: sessionOptions.cookieSameSite,
    domain: sessionOptions.domain || void 0
  });
};
const checkSessionExpirationTime = (session, sessionExpiryInSeconds) => {
  const now = dayjs();
  if (now.diff(dayjs(session.createdAt), "seconds") > sessionExpiryInSeconds) {
    throw new SessionExpired();
  }
};
const getCurrentSessionId = (event) => {
  const sessionIdRequest = parseCookies(event).sessionId;
  const sessionIdContext = event.context.sessionId;
  if (sessionIdContext && sessionIdRequest && sessionIdContext !== sessionIdRequest) {
    return null;
  }
  return sessionIdRequest || sessionIdContext || null;
};
export const deleteSession = async (event) => {
  const currentSessionId = getCurrentSessionId(event);
  if (currentSessionId) {
    await dropStorageSession(currentSessionId);
  }
  deleteCookie(event, SESSION_COOKIE_NAME);
};
const newSession = async (event) => {
  const runtimeConfig = useRuntimeConfig();
  const sessionOptions = runtimeConfig.session.session;
  const now = new Date();
  const sessionId = nanoid(sessionOptions.idLength);
  safeSetCookie(event, SESSION_COOKIE_NAME, sessionId, now);
  const session = {
    id: sessionId,
    createdAt: now,
    ip: sessionOptions.ipPinning ? await getHashedIpAddress(event) : void 0
  };
  await setStorageSession(sessionId, session);
  return session;
};
const getSession = async (event) => {
  const existingSessionId = getCurrentSessionId(event);
  if (!existingSessionId) {
    return null;
  }
  const session = await getStorageSession(existingSessionId);
  if (!isSession(session)) {
    return null;
  }
  const runtimeConfig = useRuntimeConfig();
  const sessionOptions = runtimeConfig.session.session;
  const sessionExpiryInSeconds = sessionOptions.expiryInSeconds;
  try {
    if (sessionExpiryInSeconds !== false) {
      checkSessionExpirationTime(session, sessionExpiryInSeconds);
    }
    if (sessionOptions.ipPinning) {
      await processSessionIp(event, session);
    }
  } catch {
    await deleteSession(event);
    return null;
  }
  return session;
};
const updateSessionExpirationDate = (session, event) => {
  const now = new Date();
  safeSetCookie(event, SESSION_COOKIE_NAME, session.id, now);
  return { ...session, createdAt: now };
};
function isSession(shape) {
  return typeof shape === "object" && !!shape && "id" in shape && "createdAt" in shape;
}
const ensureSession = async (event) => {
  const sessionOptions = useRuntimeConfig().session.session;
  let session = await getSession(event);
  if (!session) {
    session = await newSession(event);
  } else if (sessionOptions.rolling) {
    session = updateSessionExpirationDate(session, event);
  }
  event.context.sessionId = session.id;
  event.context.session = session;
  return session;
};
export default eventHandler(async (event) => {
  await ensureSession(event);
  event.res.on("finish", async () => {
    const session = await getSession(event);
    if (!session) {
      return;
    }
    await setStorageSession(session.id, event.context.session);
  });
});
