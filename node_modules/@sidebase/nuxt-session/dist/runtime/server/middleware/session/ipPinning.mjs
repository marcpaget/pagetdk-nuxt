import * as argon2 from "argon2";
import { IpMissingFromSession, IpMismatch } from "./exceptions.mjs";
import { useRuntimeConfig } from "#imports";
const argon2Options = {
  type: argon2.argon2id,
  hashLength: 60
};
export const hashIpAddress = (ip) => !ip ? Promise.resolve(void 0) : argon2.hash(ip, argon2Options);
export const ipAddressesMatch = (ip, ipHash) => !ip && !ipHash ? Promise.resolve(false) : argon2.verify(ipHash, ip, argon2Options);
const extractIpFromHeader = (header) => {
  if (Array.isArray(header)) {
    return header[0].split(",")[0];
  }
  if (typeof header === "string") {
    return header.split(",")[0];
  }
  return void 0;
};
export const getRequestIpAddress = ({ req }) => {
  const sessionOptions = useRuntimeConfig().session.session;
  const headerName = sessionOptions.ipPinning?.headerName;
  if (typeof sessionOptions.ipPinning === "object" && "headerName" in sessionOptions.ipPinning.headerName) {
    return extractIpFromHeader(req.headers[headerName.toLowerCase()]);
  }
  return req.socket.remoteAddress;
};
export const getHashedIpAddress = (event) => {
  return hashIpAddress(getRequestIpAddress(event));
};
export const processSessionIp = async (event, session) => {
  const hashedIP = session.ip;
  if (!hashedIP) {
    throw new IpMissingFromSession();
  }
  const requestIP = getRequestIpAddress(event);
  const matches = await ipAddressesMatch(requestIP, hashedIP);
  if (!matches) {
    throw new IpMismatch();
  }
};
